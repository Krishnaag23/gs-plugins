/* tslint:disable */
/* eslint-disable */
/**
 * Entity Service
 * **API documentation for Entity Service** 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionBy
 */
export interface ActionBy {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof ActionBy
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ActionBy
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionBy
     */
    'appId'?: string;
}
/**
 * 
 * @export
 * @interface ActionInfo
 */
export interface ActionInfo {
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof ActionInfo
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof ActionInfo
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof ActionInfo
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof ActionInfo
     */
    'updatedBy'?: ActionBy;
}
/**
 * address type data type, which consists below fields.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * house number of the address
     * @type {string}
     * @memberof Address
     */
    'buildingNumber': string;
    /**
     * address line1 of the address
     * @type {string}
     * @memberof Address
     */
    'addressLine1': string;
    /**
     * address line2 of the address
     * @type {string}
     * @memberof Address
     */
    'addressLine2'?: string;
    /**
     * address line3 of the address
     * @type {string}
     * @memberof Address
     */
    'addressLine3'?: string;
    /**
     * city of the address
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * district or country name
     * @type {string}
     * @memberof Address
     */
    'county'?: string;
    /**
     * state of the address
     * @type {string}
     * @memberof Address
     */
    'state': string;
    /**
     * postal code of the address
     * @type {string}
     * @memberof Address
     */
    'zipCode': string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    'country': Country;
    /**
     * 
     * @type {GeoLocation}
     * @memberof Address
     */
    'geolocation'?: GeoLocation;
    /**
     * meta info about location
     * @type {object}
     * @memberof Address
     */
    'tag'?: object;
}
/**
 * 
 * @export
 * @interface AggregateResponse
 */
export interface AggregateResponse {
    /**
     * 
     * @type {AggregateResponseData}
     * @memberof AggregateResponse
     */
    'data'?: AggregateResponseData;
    /**
     * 
     * @type {Request}
     * @memberof AggregateResponse
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface AggregateResponseData
 */
export interface AggregateResponseData {
    /**
     * 
     * @type {{ [key: string]: AggregateResponseDataAggregateResultValue; }}
     * @memberof AggregateResponseData
     */
    'aggregateResult'?: { [key: string]: AggregateResponseDataAggregateResultValue; };
}
/**
 * the key name will be same as unique key\'s name sent in aggregateQuery request
 * @export
 * @interface AggregateResponseDataAggregateResultValue
 */
export interface AggregateResponseDataAggregateResultValue {
    /**
     * 
     * @type {number}
     * @memberof AggregateResponseDataAggregateResultValue
     */
    'doc_count_error_upper_bound'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregateResponseDataAggregateResultValue
     */
    'sum_other_doc_count'?: number;
    /**
     * 
     * @type {Array<AggregateResponseDataAggregateResultValueBucketsInner>}
     * @memberof AggregateResponseDataAggregateResultValue
     */
    'buckets'?: Array<AggregateResponseDataAggregateResultValueBucketsInner>;
}
/**
 * 
 * @export
 * @interface AggregateResponseDataAggregateResultValueBucketsInner
 */
export interface AggregateResponseDataAggregateResultValueBucketsInner {
    /**
     * 
     * @type {string}
     * @memberof AggregateResponseDataAggregateResultValueBucketsInner
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregateResponseDataAggregateResultValueBucketsInner
     */
    'doc_count'?: number;
}
/**
 * 
 * @export
 * @interface AppOnboardResponse
 */
export interface AppOnboardResponse {
    /**
     * 
     * @type {AppOnboardResponseData}
     * @memberof AppOnboardResponse
     */
    'data': AppOnboardResponseData;
    /**
     * 
     * @type {Request}
     * @memberof AppOnboardResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface AppOnboardResponseData
 */
export interface AppOnboardResponseData {
    /**
     * 
     * @type {string}
     * @memberof AppOnboardResponseData
     */
    'status'?: string;
    /**
     * 
     * @type {Array<AppOnboardResponseDataMetaInner>}
     * @memberof AppOnboardResponseData
     */
    'meta'?: Array<AppOnboardResponseDataMetaInner>;
}
/**
 * 
 * @export
 * @interface AppOnboardResponseDataMetaInner
 */
export interface AppOnboardResponseDataMetaInner {
    /**
     * 
     * @type {string}
     * @memberof AppOnboardResponseDataMetaInner
     */
    'task'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppOnboardResponseDataMetaInner
     */
    'status'?: AppOnboardResponseDataMetaInnerStatusEnum;
}

export const AppOnboardResponseDataMetaInnerStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type AppOnboardResponseDataMetaInnerStatusEnum = typeof AppOnboardResponseDataMetaInnerStatusEnum[keyof typeof AppOnboardResponseDataMetaInnerStatusEnum];

/**
 * entity type attributes configuration
 * @export
 * @interface AttributeConfig
 */
export interface AttributeConfig {
    /**
     * 
     * @type {string}
     * @memberof AttributeConfig
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeConfig
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeConfig
     */
    'isReadPublic'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributeConfig
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {DataType}
     * @memberof AttributeConfig
     */
    'dataType': DataType;
    /**
     * defines whether to make this attribute indexed or not so that filtering can be provided based on this attribute.
     * @type {boolean}
     * @memberof AttributeConfig
     */
    'indexed'?: boolean;
    /**
     * 
     * @type {DefaultValue}
     * @memberof AttributeConfig
     */
    'defaultValue'?: DefaultValue;
    /**
     * 
     * @type {Validation}
     * @memberof AttributeConfig
     */
    'validation'?: Validation;
}


/**
 * entity type core attributes configuration on get call
 * @export
 * @interface AttributeConfigGet
 */
export interface AttributeConfigGet {
    /**
     * 
     * @type {string}
     * @memberof AttributeConfigGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeConfigGet
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeConfigGet
     */
    'ownerAppId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeConfigGet
     */
    'description'?: string;
    /**
     * 
     * @type {DataType}
     * @memberof AttributeConfigGet
     */
    'dataType': DataType;
    /**
     * defines whether to make this attribute indexed or not so that filtering can be provided based on this attribute.
     * @type {boolean}
     * @memberof AttributeConfigGet
     */
    'indexed'?: boolean;
    /**
     * 
     * @type {DefaultValue}
     * @memberof AttributeConfigGet
     */
    'defaultValue'?: DefaultValue;
    /**
     * 
     * @type {Validation}
     * @memberof AttributeConfigGet
     */
    'validation'?: Validation;
}


/**
 * entity type attributes configuration
 * @export
 * @interface AttributeConfigTemplate
 */
export interface AttributeConfigTemplate {
    /**
     * 
     * @type {string}
     * @memberof AttributeConfigTemplate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeConfigTemplate
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributeConfigTemplate
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {DataType}
     * @memberof AttributeConfigTemplate
     */
    'dataType': DataType;
    /**
     * defines whether to make this attribute indexed or not so that filtering can be provided based on this attribute.
     * @type {boolean}
     * @memberof AttributeConfigTemplate
     */
    'indexed'?: boolean;
    /**
     * 
     * @type {DefaultValue}
     * @memberof AttributeConfigTemplate
     */
    'defaultValue'?: DefaultValue;
    /**
     * 
     * @type {Validation}
     * @memberof AttributeConfigTemplate
     */
    'validation'?: Validation;
}


/**
 * 
 * @export
 * @interface AttributeConfigsGet
 */
export interface AttributeConfigsGet {
    /**
     * 
     * @type {Array<AttributesByTag>}
     * @memberof AttributeConfigsGet
     */
    'coreAttributesByTag'?: Array<AttributesByTag>;
    /**
     * 
     * @type {Array<AttributeConfigGet>}
     * @memberof AttributeConfigsGet
     */
    'attributes'?: Array<AttributeConfigGet>;
}
/**
 * Attributes of an Entity.
 * @export
 * @interface Attributes
 */
export interface Attributes {
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof Attributes
     */
    'properties': object;
}
/**
 * 
 * @export
 * @interface AttributesByTag
 */
export interface AttributesByTag {
    /**
     * 
     * @type {string}
     * @memberof AttributesByTag
     */
    'tag'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributesByTag
     */
    'attributes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AttributesConfig
 */
export interface AttributesConfig {
    /**
     * 
     * @type {Array<AttributeConfig>}
     * @memberof AttributesConfig
     */
    'attributes'?: Array<AttributeConfig>;
}
/**
 * 
 * @export
 * @interface AttributesConfigGet
 */
export interface AttributesConfigGet {
    /**
     * 
     * @type {Array<AttributeConfigGet>}
     * @memberof AttributesConfigGet
     */
    'attributes'?: Array<AttributeConfigGet>;
}
/**
 * 
 * @export
 * @interface AttributesConfigResponse
 */
export interface AttributesConfigResponse {
    /**
     * 
     * @type {Error}
     * @memberof AttributesConfigResponse
     */
    'error'?: Error;
    /**
     * 
     * @type {AttributesConfigResponseData}
     * @memberof AttributesConfigResponse
     */
    'data'?: AttributesConfigResponseData;
    /**
     * 
     * @type {Request}
     * @memberof AttributesConfigResponse
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface AttributesConfigResponseData
 */
export interface AttributesConfigResponseData {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof AttributesConfigResponseData
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof AttributesConfigResponseData
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributesConfigResponseData
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof AttributesConfigResponseData
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof AttributesConfigResponseData
     */
    'alias'?: BaseEntityTypeAlias;
    /**
     * 
     * @type {boolean}
     * @memberof AttributesConfigResponseData
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttributesConfigResponseData
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributesConfigResponseData
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {Array<AttributeConfig>}
     * @memberof AttributesConfigResponseData
     */
    'attributes'?: Array<AttributeConfig>;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof AttributesConfigResponseData
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof AttributesConfigResponseData
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof AttributesConfigResponseData
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof AttributesConfigResponseData
     */
    'updatedBy'?: ActionBy;
}
/**
 * Update base and core attributes config
 * @export
 * @interface AttributesConfigUpdateRequest
 */
export interface AttributesConfigUpdateRequest {
    /**
     * 
     * @type {Array<AttributeConfig>}
     * @memberof AttributesConfigUpdateRequest
     */
    'attributes'?: Array<AttributeConfig>;
}
/**
 * Base attributes of a Entity.
 * @export
 * @interface BaseAttributes
 */
export interface BaseAttributes {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof BaseAttributes
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof BaseAttributes
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof BaseAttributes
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof BaseAttributes
     */
    'subCategory'?: string;
}
/**
 * Base attributes of a Entity.
 * @export
 * @interface BaseAttributesNullable
 */
export interface BaseAttributesNullable {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof BaseAttributesNullable
     */
    'name'?: string | null;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof BaseAttributesNullable
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof BaseAttributesNullable
     */
    'category'?: string | null;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof BaseAttributesNullable
     */
    'subCategory'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseChange
 */
export interface BaseChange {
    /**
     * 
     * @type {ChangeAction}
     * @memberof BaseChange
     */
    'action': ChangeAction;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof BaseChange
     */
    'actionTime': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof BaseChange
     */
    'actionBy': ActionBy;
    /**
     * 
     * @type {string}
     * @memberof BaseChange
     */
    'channel': string;
}


/**
 * 
 * @export
 * @interface BaseEntityType
 */
export interface BaseEntityType {
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof BaseEntityType
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof BaseEntityType
     */
    'alias'?: BaseEntityTypeAlias;
}
/**
 * 
 * @export
 * @interface BaseEntityTypeAlias
 */
export interface BaseEntityTypeAlias {
    /**
     * A term that labels multiple Entities of this entity type. This is used as collection name in resource URL for this entity type and as Entity id prefix.
     * @type {string}
     * @memberof BaseEntityTypeAlias
     */
    'plural': string;
    /**
     * A *singular label* of an Entity Type
     * @type {string}
     * @memberof BaseEntityTypeAlias
     */
    'singular': string;
}
/**
 * 
 * @export
 * @interface BaseEntityTypeChange
 */
export interface BaseEntityTypeChange {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof BaseEntityTypeChange
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseEntityTypeChange
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseEntityTypeChange
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof BaseEntityTypeChange
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof BaseEntityTypeChange
     */
    'alias'?: BaseEntityTypeAlias;
    /**
     * 
     * @type {boolean}
     * @memberof BaseEntityTypeChange
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseEntityTypeChange
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseEntityTypeChange
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {Array<AttributeConfig>}
     * @memberof BaseEntityTypeChange
     */
    'attributes'?: Array<AttributeConfig>;
}
/**
 * 
 * @export
 * @interface BaseEntityTypeName
 */
export interface BaseEntityTypeName {
    /**
     * A unique *plural name* i.e. a term that defines multiple Entities of this entity type. This is used as collection name in resource URL for this entity type and as Entity id prefix.
     * @type {string}
     * @memberof BaseEntityTypeName
     */
    'plural': string;
    /**
     * A *singular name* of an Entity Type
     * @type {string}
     * @memberof BaseEntityTypeName
     */
    'singular': string;
}
/**
 * 
 * @export
 * @interface BasicEntityInfo
 */
export interface BasicEntityInfo {
    /**
     * 
     * @type {string}
     * @memberof BasicEntityInfo
     */
    'entityName': string;
}
/**
 * 
 * @export
 * @interface BasicParams
 */
export interface BasicParams {
    /**
     * 
     * @type {string}
     * @memberof BasicParams
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof BasicParams
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof BasicParams
     */
    'ownerAppId'?: string;
}
/**
 * 
 * @export
 * @interface BasicTemplateInfo
 */
export interface BasicTemplateInfo {
    /**
     * 
     * @type {string}
     * @memberof BasicTemplateInfo
     */
    'templateId'?: string;
}
/**
 * 
 * @export
 * @interface BasicTemplateInfoNullable
 */
export interface BasicTemplateInfoNullable {
    /**
     * 
     * @type {string}
     * @memberof BasicTemplateInfoNullable
     */
    'templateId'?: string | null;
}
/**
 * Base attributes of a Entity.
 * @export
 * @interface BatchBaseAttributes
 */
export interface BatchBaseAttributes {
    /**
     * 
     * @type {string}
     * @memberof BatchBaseAttributes
     */
    'uniqueCode': string;
    /**
     * Name of the Entity
     * @type {string}
     * @memberof BatchBaseAttributes
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof BatchBaseAttributes
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof BatchBaseAttributes
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof BatchBaseAttributes
     */
    'subCategory'?: string;
    /**
     * 
     * @type {object}
     * @memberof BatchBaseAttributes
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface BatchRecordError
 */
export interface BatchRecordError {
    /**
     * Id of the Entity Instance.
     * @type {string}
     * @memberof BatchRecordError
     */
    'id'?: string;
    /**
     * UniqueCode of the Entity Instance.
     * @type {string}
     * @memberof BatchRecordError
     */
    'uniqueCode'?: string;
    /**
     * failure reason of record.
     * @type {string}
     * @memberof BatchRecordError
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface BatchResponse
 */
export interface BatchResponse {
    /**
     * 
     * @type {BatchResponseMetaData}
     * @memberof BatchResponse
     */
    'meta'?: BatchResponseMetaData;
    /**
     * 
     * @type {Array<BatchRecordError>}
     * @memberof BatchResponse
     */
    'errors'?: Array<BatchRecordError>;
    /**
     * 
     * @type {Array<BatchResponseSuccess>}
     * @memberof BatchResponse
     */
    'success'?: Array<BatchResponseSuccess>;
}
/**
 * 
 * @export
 * @interface BatchResponseMetaData
 */
export interface BatchResponseMetaData {
    /**
     * status of batch request
     * @type {string}
     * @memberof BatchResponseMetaData
     */
    'status'?: string;
    /**
     * total number of successful record.
     * @type {number}
     * @memberof BatchResponseMetaData
     */
    'success'?: number;
    /**
     * total number of failed records.
     * @type {number}
     * @memberof BatchResponseMetaData
     */
    'failed'?: number;
    /**
     * total number of record.
     * @type {number}
     * @memberof BatchResponseMetaData
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface BatchResponseSuccess
 */
export interface BatchResponseSuccess {
    /**
     * id of Entity.
     * @type {string}
     * @memberof BatchResponseSuccess
     */
    'id'?: string;
    /**
     * uniqueCode of Entity
     * @type {string}
     * @memberof BatchResponseSuccess
     */
    'uniqueCode'?: string;
}
/**
 * 
 * @export
 * @interface BatchSuccessResponse
 */
export interface BatchSuccessResponse {
    /**
     * 
     * @type {BatchSuccessResponseData}
     * @memberof BatchSuccessResponse
     */
    'data': BatchSuccessResponseData;
    /**
     * 
     * @type {Request}
     * @memberof BatchSuccessResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface BatchSuccessResponseData
 */
export interface BatchSuccessResponseData {
    /**
     * Unique UUID of a batch request.
     * @type {string}
     * @memberof BatchSuccessResponseData
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CallbackForInstance
 */
export interface CallbackForInstance {
    /**
     * URL to notify the outcome of the request.
     * @type {string}
     * @memberof CallbackForInstance
     */
    'url'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CallbackForInstance
     */
    'meta'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CallbackMeta
 */
export interface CallbackMeta {
    /**
     * URL to notify the outcome of the request.
     * @type {string}
     * @memberof CallbackMeta
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CallbackMeta
     */
    'meta'?: { [key: string]: any; };
}
/**
 * Name and attributes of a category
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Category
     */
    'subCategory': Array<string>;
}
/**
 * Action for data auditing
 * @export
 * @enum {string}
 */

export const ChangeAction = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Get: 'GET',
    Delete: 'DELETE'
} as const;

export type ChangeAction = typeof ChangeAction[keyof typeof ChangeAction];


/**
 * entity type core attributes configuration
 * @export
 * @interface CoreAttributeConfig
 */
export interface CoreAttributeConfig {
    /**
     * name of the core attribute
     * @type {string}
     * @memberof CoreAttributeConfig
     */
    'name': string;
    /**
     * alias of the core attribute
     * @type {string}
     * @memberof CoreAttributeConfig
     */
    'alias': string;
}
/**
 * country which consists code and name
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * code of the country
     * @type {string}
     * @memberof Country
     */
    'code': string;
    /**
     * name of the country
     * @type {string}
     * @memberof Country
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CustomCallErrorObject
 */
export interface CustomCallErrorObject {
    /**
     * request URL for the custom call
     * @type {string}
     * @memberof CustomCallErrorObject
     */
    'url': string;
    /**
     * request headers object for custom call
     * @type {object}
     * @memberof CustomCallErrorObject
     */
    'requestHeader': object;
    /**
     * request body object for custom call
     * @type {object}
     * @memberof CustomCallErrorObject
     */
    'requestBody'?: object;
    /**
     * 
     * @type {Method}
     * @memberof CustomCallErrorObject
     */
    'method': Method;
    /**
     * 
     * @type {OnResponseForOnErrorObject}
     * @memberof CustomCallErrorObject
     */
    'onResponse': OnResponseForOnErrorObject;
}


/**
 * 
 * @export
 * @interface CustomCallRequestObject
 */
export interface CustomCallRequestObject {
    /**
     * request URL for the custom call
     * @type {string}
     * @memberof CustomCallRequestObject
     */
    'url': string;
    /**
     * request headers object for custom call
     * @type {object}
     * @memberof CustomCallRequestObject
     */
    'requestHeader': object;
    /**
     * request body object for custom call
     * @type {object}
     * @memberof CustomCallRequestObject
     */
    'requestBody'?: object;
    /**
     * 
     * @type {Method}
     * @memberof CustomCallRequestObject
     */
    'method': Method;
    /**
     * 
     * @type {OnResponseObject}
     * @memberof CustomCallRequestObject
     */
    'onResponse': OnResponseObject;
}


/**
 * 
 * @export
 * @interface CustomCodeConfigResponse
 */
export interface CustomCodeConfigResponse {
    /**
     * 
     * @type {CustomCodeGetResponseData}
     * @memberof CustomCodeConfigResponse
     */
    'data'?: CustomCodeGetResponseData;
    /**
     * 
     * @type {Request}
     * @memberof CustomCodeConfigResponse
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface CustomCodeCreateRequest
 */
export interface CustomCodeCreateRequest {
    /**
     * request URL for the custom call
     * @type {string}
     * @memberof CustomCodeCreateRequest
     */
    'url': string;
    /**
     * request headers object for custom call
     * @type {object}
     * @memberof CustomCodeCreateRequest
     */
    'requestHeader': object;
    /**
     * 
     * @type {Method}
     * @memberof CustomCodeCreateRequest
     */
    'method': Method;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeCreateRequest
     */
    'wait': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomCodeCreateRequest
     */
    'acceptableStatusCodes'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeCreateRequest
     */
    'raiseErrorOnStatusMismatch'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeCreateRequest
     */
    'methodName': CustomCodeCreateRequestMethodNameEnum;
}

export const CustomCodeCreateRequestMethodNameEnum = {
    CreateonError: 'create:onError',
    UpdateonError: 'update:onError',
    ApplyEventonError: 'apply_event:onError',
    CreateonRequest: 'create:onRequest',
    UpdateonRequest: 'update:onRequest',
    ApplyEventonRequest: 'apply_event:onRequest'
} as const;

export type CustomCodeCreateRequestMethodNameEnum = typeof CustomCodeCreateRequestMethodNameEnum[keyof typeof CustomCodeCreateRequestMethodNameEnum];

/**
 * 
 * @export
 * @interface CustomCodeGetResponseData
 */
export interface CustomCodeGetResponseData {
    /**
     * request URL for the custom call
     * @type {string}
     * @memberof CustomCodeGetResponseData
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseData
     */
    'id'?: string;
    /**
     * request headers object for custom call
     * @type {object}
     * @memberof CustomCodeGetResponseData
     */
    'requestHeader'?: object;
    /**
     * request body object for custom call
     * @type {object}
     * @memberof CustomCodeGetResponseData
     */
    'requestBody'?: object;
    /**
     * 
     * @type {Method}
     * @memberof CustomCodeGetResponseData
     */
    'method'?: Method;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeGetResponseData
     */
    'wait'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomCodeGetResponseData
     */
    'acceptableStatusCodes'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeGetResponseData
     */
    'raiseErrorOnStatusMismatch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeGetResponseData
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseData
     */
    'methodName'?: CustomCodeGetResponseDataMethodNameEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseData
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseData
     */
    'serviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseData
     */
    'tenantId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomCodeGetResponseData
     */
    'createdAt'?: number;
    /**
     * 
     * @type {CustomCodeGetResponseDataCreatedBy}
     * @memberof CustomCodeGetResponseData
     */
    'createdBy'?: CustomCodeGetResponseDataCreatedBy;
    /**
     * 
     * @type {number}
     * @memberof CustomCodeGetResponseData
     */
    'updatedAt'?: number;
    /**
     * 
     * @type {CustomCodeGetResponseDataCreatedBy}
     * @memberof CustomCodeGetResponseData
     */
    'updatedBy'?: CustomCodeGetResponseDataCreatedBy;
}

export const CustomCodeGetResponseDataMethodNameEnum = {
    CreateonRequest: 'create:onRequest',
    UpdateonRequest: 'update:onRequest',
    ApplyEventonRequest: 'apply_event:onRequest',
    CreateonError: 'create:onError',
    UpdateonError: 'update:onError',
    ApplyEventonError: 'apply_event:onError'
} as const;

export type CustomCodeGetResponseDataMethodNameEnum = typeof CustomCodeGetResponseDataMethodNameEnum[keyof typeof CustomCodeGetResponseDataMethodNameEnum];

/**
 * 
 * @export
 * @interface CustomCodeGetResponseDataCreatedBy
 */
export interface CustomCodeGetResponseDataCreatedBy {
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseDataCreatedBy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomCodeGetResponseDataCreatedBy
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CustomCodeUpdateRequest
 */
export interface CustomCodeUpdateRequest {
    /**
     * request URL for the custom call
     * @type {string}
     * @memberof CustomCodeUpdateRequest
     */
    'url'?: string;
    /**
     * request headers object for custom call
     * @type {object}
     * @memberof CustomCodeUpdateRequest
     */
    'requestHeader'?: object;
    /**
     * 
     * @type {Method}
     * @memberof CustomCodeUpdateRequest
     */
    'method'?: Method;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeUpdateRequest
     */
    'wait'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomCodeUpdateRequest
     */
    'acceptableStatusCodes'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeUpdateRequest
     */
    'raiseErrorOnStatusMismatch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomCodeUpdateRequest
     */
    'enabled'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Object: 'object',
    Array: 'array',
    Address: 'address',
    Phone: 'phone',
    Money: 'money',
    GeoPoint: 'geo_point'
} as const;

export type DataType = typeof DataType[keyof typeof DataType];


/**
 * provide default value of the attribute. Data type of the value should match the data type of the attribute defined.
 * @export
 * @interface DefaultValue
 */
export interface DefaultValue {
}
/**
 * Destination state for instace state transition.
 * @export
 * @interface DestinationState
 */
export interface DestinationState {
    /**
     * Represents the main state to which we want to override the instance.
     * @type {string}
     * @memberof DestinationState
     */
    'state': string;
    /**
     * Substate is optional, if not specified then will be populated by default substate of that main state.
     * @type {string}
     * @memberof DestinationState
     */
    'subState'?: string;
    /**
     * Represents callback url, which can be called to notify the status of API request.
     * @type {string}
     * @memberof DestinationState
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface EntitiesResponse
 */
export interface EntitiesResponse {
    /**
     * 
     * @type {EntitiesResponseData}
     * @memberof EntitiesResponse
     */
    'data': EntitiesResponseData;
    /**
     * 
     * @type {Request}
     * @memberof EntitiesResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface EntitiesResponseData
 */
export interface EntitiesResponseData {
    /**
     * 
     * @type {TemplatesResponseDataMeta}
     * @memberof EntitiesResponseData
     */
    'meta'?: TemplatesResponseDataMeta;
    /**
     * 
     * @type {Array<EntityResponseData>}
     * @memberof EntitiesResponseData
     */
    'entityInstances'?: Array<EntityResponseData>;
}
/**
 * Entity attributes
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof Entity
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof Entity
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof Entity
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof Entity
     */
    'subCategory'?: string;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof Entity
     */
    'properties': object;
}
/**
 * 
 * @export
 * @interface EntityBatch
 */
export interface EntityBatch {
    /**
     * list of valid objects to perform create data in Entities
     * @type {Array<EntityBatchCreate>}
     * @memberof EntityBatch
     */
    'payload': Array<EntityBatchCreate>;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityBatch
     */
    'callback'?: CallbackForInstance;
}
/**
 * 
 * @export
 * @interface EntityBatchCallbackData
 */
export interface EntityBatchCallbackData {
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'batchId'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityBatchCallbackData
     */
    'batchType'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'request'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityBatchCallbackData
     */
    'response'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityBatchCallbackData
     */
    'unProcessed'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCallbackData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityBatchCallbackData
     */
    'createdBy'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityBatchCallbackData
     */
    'updatedBy'?: object;
}
/**
 * Create new Entity.
 * @export
 * @interface EntityBatchCreate
 */
export interface EntityBatchCreate {
    /**
     * 
     * @type {string}
     * @memberof EntityBatchCreate
     */
    'uniqueCode': string;
    /**
     * Name of the Entity
     * @type {string}
     * @memberof EntityBatchCreate
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof EntityBatchCreate
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof EntityBatchCreate
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof EntityBatchCreate
     */
    'subCategory'?: string;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof EntityBatchCreate
     */
    'properties': object;
}
/**
 * Provide Entity create data in batch
 * @export
 * @interface EntityBatchCreateRequest
 */
export interface EntityBatchCreateRequest {
    /**
     * list of valid objects to perform create data in Entities
     * @type {Array<EntityBatchCreate>}
     * @memberof EntityBatchCreateRequest
     */
    'payload': Array<EntityBatchCreate>;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityBatchCreateRequest
     */
    'callback'?: CallbackForInstance;
}
/**
 * 
 * @export
 * @interface EntityBatchFailedCallbackRequest
 */
export interface EntityBatchFailedCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'businessCommand': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'entityVersion': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'commandName': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'payloadValidated': boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'entityInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'requestId': string;
    /**
     * 
     * @type {EntityBatchCallbackData}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'data'?: EntityBatchCallbackData;
    /**
     * 
     * @type {object}
     * @memberof EntityBatchFailedCallbackRequest
     */
    'callbackMeta'?: object;
}
/**
 * 
 * @export
 * @interface EntityBatchResponse
 */
export interface EntityBatchResponse {
    /**
     * 
     * @type {EntityBatchResponseData}
     * @memberof EntityBatchResponse
     */
    'data': EntityBatchResponseData;
    /**
     * 
     * @type {Request}
     * @memberof EntityBatchResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface EntityBatchResponseData
 */
export interface EntityBatchResponseData {
    /**
     * 
     * @type {BatchResponseMetaData}
     * @memberof EntityBatchResponseData
     */
    'meta'?: BatchResponseMetaData;
    /**
     * 
     * @type {Array<BatchRecordError>}
     * @memberof EntityBatchResponseData
     */
    'errors'?: Array<BatchRecordError>;
    /**
     * 
     * @type {Array<BatchResponseSuccess>}
     * @memberof EntityBatchResponseData
     */
    'success'?: Array<BatchResponseSuccess>;
}
/**
 * 
 * @export
 * @interface EntityBatchSuccessCallbackRequest
 */
export interface EntityBatchSuccessCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'businessCommand': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'entityVersion': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'commandName': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'payloadValidated': boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'entityInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'requestId': string;
    /**
     * 
     * @type {EntityBatchCallbackData}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'data'?: EntityBatchCallbackData;
    /**
     * 
     * @type {object}
     * @memberof EntityBatchSuccessCallbackRequest
     */
    'callbackMeta'?: object;
}
/**
 * 
 * @export
 * @interface EntityBatchUpdate
 */
export interface EntityBatchUpdate {
    /**
     * list of valid objects to perform update data in Entities
     * @type {Array<EntityBatchUpdateData>}
     * @memberof EntityBatchUpdate
     */
    'payload': Array<EntityBatchUpdateData>;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityBatchUpdate
     */
    'callback'?: CallbackForInstance;
}
/**
 * 
 * @export
 * @interface EntityBatchUpdateData
 */
export interface EntityBatchUpdateData {
    /**
     * unique Entity id
     * @type {string}
     * @memberof EntityBatchUpdateData
     */
    'entityInstanceId': string;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof EntityBatchUpdateData
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchUpdateData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchUpdateData
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchUpdateData
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchUpdateData
     */
    'subCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityBatchUpdateData
     */
    'templateId'?: string;
}
/**
 * Provide Entity update data in batch
 * @export
 * @interface EntityBatchUpdateRequest
 */
export interface EntityBatchUpdateRequest {
    /**
     * list of valid objects to perform update data in Entities
     * @type {Array<EntityBatchUpdateData>}
     * @memberof EntityBatchUpdateRequest
     */
    'payload': Array<EntityBatchUpdateData>;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityBatchUpdateRequest
     */
    'callback'?: CallbackForInstance;
}
/**
 * Entity CDC
 * @export
 * @interface EntityCDC
 */
export interface EntityCDC {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof EntityCDC
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof EntityCDC
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof EntityCDC
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof EntityCDC
     */
    'subCategory'?: string;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof EntityCDC
     */
    'properties': object;
}
/**
 * Entity change
 * @export
 * @interface EntityChange
 */
export interface EntityChange {
    /**
     * 
     * @type {ChangeAction}
     * @memberof EntityChange
     */
    'action': ChangeAction;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityChange
     */
    'actionTime': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityChange
     */
    'actionBy': ActionBy;
    /**
     * 
     * @type {string}
     * @memberof EntityChange
     */
    'channel': string;
    /**
     * 
     * @type {EntityCDC}
     * @memberof EntityChange
     */
    'cdc': EntityCDC;
}


/**
 * 
 * @export
 * @interface EntityChangeLogResponse
 */
export interface EntityChangeLogResponse {
    /**
     * 
     * @type {Error}
     * @memberof EntityChangeLogResponse
     */
    'error'?: Error;
    /**
     * 
     * @type {EntityChangeLogResponseData}
     * @memberof EntityChangeLogResponse
     */
    'data'?: EntityChangeLogResponseData;
    /**
     * 
     * @type {Request}
     * @memberof EntityChangeLogResponse
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface EntityChangeLogResponseData
 */
export interface EntityChangeLogResponseData {
    /**
     * 
     * @type {TemplatesResponseDataMeta}
     * @memberof EntityChangeLogResponseData
     */
    'meta'?: TemplatesResponseDataMeta;
    /**
     * 
     * @type {Array<EntityChange>}
     * @memberof EntityChangeLogResponseData
     */
    'log'?: Array<EntityChange>;
}
/**
 * Create new Entity
 * @export
 * @interface EntityCreateRequest
 */
export interface EntityCreateRequest {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof EntityCreateRequest
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof EntityCreateRequest
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof EntityCreateRequest
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof EntityCreateRequest
     */
    'subCategory'?: string;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof EntityCreateRequest
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequest
     */
    'templateId'?: string;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityCreateRequest
     */
    'callback'?: CallbackForInstance;
}
/**
 * 
 * @export
 * @interface EntityCreateRequestCategory
 */
export interface EntityCreateRequestCategory {
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'uniqueCode': string;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'subCategory'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityCreateRequestCategory
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'templateId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityCreateRequestCategory
     */
    'state'?: string;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityCreateRequestCategory
     */
    'callback'?: CallbackForInstance;
    /**
     * 
     * @type {CustomCallRequestObject}
     * @memberof EntityCreateRequestCategory
     */
    'onRequest'?: CustomCallRequestObject;
    /**
     * 
     * @type {CustomCallErrorObject}
     * @memberof EntityCreateRequestCategory
     */
    'onError'?: CustomCallErrorObject;
    /**
     * expiry datetime in epoch (sec) (> current date and < 6 months from current date)
     * @type {number}
     * @memberof EntityCreateRequestCategory
     */
    'TTL'?: number | null;
}
/**
 * 
 * @export
 * @interface EntityInstanceCallbackData
 */
export interface EntityInstanceCallbackData {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'uniqueCode': string;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceCallbackData
     */
    'properties'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceCallbackData
     */
    'createdBy'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceCallbackData
     */
    'updatedBy'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'owner'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityInstanceCallbackData
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackData
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface EntityInstanceCallbackDataForEntity
 */
export interface EntityInstanceCallbackDataForEntity {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'entityType'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'schemaNamespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'schemaVersion'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'entityMeta'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'aggreagteRoot'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'tenantid': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'entityinstanceid': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'entityid': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'appid': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'entityname': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'uniquecode'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'isactive'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'attributes'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'state'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'created_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'updated_at'?: number;
    /**
     * 
     * @type {EntityInstanceCallbackDataForEntityUpdatedBy}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'updated_by'?: EntityInstanceCallbackDataForEntityUpdatedBy;
    /**
     * 
     * @type {EntityInstanceCallbackDataForEntityUpdatedBy}
     * @memberof EntityInstanceCallbackDataForEntity
     */
    'created_by'?: EntityInstanceCallbackDataForEntityUpdatedBy;
}
/**
 * 
 * @export
 * @interface EntityInstanceCallbackDataForEntityUpdatedBy
 */
export interface EntityInstanceCallbackDataForEntityUpdatedBy {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntityUpdatedBy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntityUpdatedBy
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCallbackDataForEntityUpdatedBy
     */
    'appId'?: string;
}
/**
 * 
 * @export
 * @interface EntityInstanceCustomApiResponse
 */
export interface EntityInstanceCustomApiResponse {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCustomApiResponse
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceCustomApiResponse
     */
    'description'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceCustomApiResponse
     */
    'additionalInfo'?: object;
}
/**
 * 
 * @export
 * @interface EntityInstanceFailedCallbackRequest
 */
export interface EntityInstanceFailedCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'businessCommand': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'entityVersion': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'commandName': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'payloadValidated': boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'errorCode': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'entityInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'requestId': string;
    /**
     * 
     * @type {EntityInstanceCallbackData}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'data'?: EntityInstanceCallbackData;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'entity': object;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'callbackMeta'?: object;
    /**
     * 
     * @type {EntityInstanceCustomApiResponse}
     * @memberof EntityInstanceFailedCallbackRequest
     */
    'customApiResponse'?: EntityInstanceCustomApiResponse;
}
/**
 * 
 * @export
 * @interface EntityInstanceSuccessCallbackRequest
 */
export interface EntityInstanceSuccessCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'businessCommand': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'entityVersion': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'commandName': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'payloadValidated': boolean;
    /**
     * reason for failure
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'reason'?: string;
    /**
     * errorCode of the failure
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'entityInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'requestId': string;
    /**
     * 
     * @type {EntityInstanceCallbackData}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'data': EntityInstanceCallbackData;
    /**
     * 
     * @type {EntityInstanceCallbackDataForEntity}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'entity': EntityInstanceCallbackDataForEntity;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceSuccessCallbackRequest
     */
    'callbackMeta'?: object;
}
/**
 * 
 * @export
 * @interface EntityInstanceSuccessCallbackRequestFailedForEntity
 */
export interface EntityInstanceSuccessCallbackRequestFailedForEntity {
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'businessCommand': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'entityVersion': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'commandName': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'payloadValidated': boolean;
    /**
     * reason for failure
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'reason'?: string;
    /**
     * errorCode of the failure
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'entityInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'requestId': string;
    /**
     * 
     * @type {EntityInstanceCallbackData}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'data': EntityInstanceCallbackData;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'entity': object;
    /**
     * 
     * @type {object}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'callbackMeta'?: object;
    /**
     * 
     * @type {EntityInstanceCustomApiResponse}
     * @memberof EntityInstanceSuccessCallbackRequestFailedForEntity
     */
    'customApiResponse'?: EntityInstanceCustomApiResponse;
}
/**
 * Entity attributes
 * @export
 * @interface EntityNullable
 */
export interface EntityNullable {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof EntityNullable
     */
    'name'?: string | null;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof EntityNullable
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof EntityNullable
     */
    'category'?: string | null;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof EntityNullable
     */
    'subCategory'?: string | null;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof EntityNullable
     */
    'properties': object;
}
/**
 * 
 * @export
 * @interface EntityResponse
 */
export interface EntityResponse {
    /**
     * 
     * @type {GetSingleEntityResponseData}
     * @memberof EntityResponse
     */
    'data': GetSingleEntityResponseData;
    /**
     * 
     * @type {Request}
     * @memberof EntityResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface EntityResponseData
 */
export interface EntityResponseData {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof EntityResponseData
     */
    'name'?: string;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof EntityResponseData
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof EntityResponseData
     */
    'category'?: string;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof EntityResponseData
     */
    'subCategory'?: string;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof EntityResponseData
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof EntityResponseData
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityResponseData
     */
    'templateId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityResponseData
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityResponseData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityResponseData
     */
    'ownerAppId'?: string;
    /**
     * default state in state machine
     * @type {string}
     * @memberof EntityResponseData
     */
    'state'?: string;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityResponseData
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityResponseData
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityResponseData
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityResponseData
     */
    'updatedBy'?: ActionBy;
    /**
     * Unique id of the instance
     * @type {any}
     * @memberof EntityResponseData
     */
    'id': any;
    /**
     * 
     * @type {string}
     * @memberof EntityResponseData
     */
    'uniqueCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityResponseData
     */
    'isActive'?: boolean;
    /**
     * TTL (epoch in seconds)
     * @type {number}
     * @memberof EntityResponseData
     */
    'TTL'?: number;
    /**
     * URL to notify the outcome of the request.
     * @type {string}
     * @memberof EntityResponseData
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface EntityTemplateCallbackData
 */
export interface EntityTemplateCallbackData {
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackData
     */
    'templateId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackData
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackData
     */
    'subCategory'?: string;
}
/**
 * 
 * @export
 * @interface EntityTemplateCallbackRequest
 */
export interface EntityTemplateCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackRequest
     */
    'entityType'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackRequest
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackRequest
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackRequest
     */
    'requestId': string;
    /**
     * 
     * @type {object}
     * @memberof EntityTemplateCallbackRequest
     */
    'callbackMeta'?: object;
    /**
     * 
     * @type {EntityTemplateCallbackData}
     * @memberof EntityTemplateCallbackRequest
     */
    'data'?: EntityTemplateCallbackData;
    /**
     * 
     * @type {string}
     * @memberof EntityTemplateCallbackRequest
     */
    'failureReason'?: string | null;
}
/**
 * Entity Type
 * @export
 * @interface EntityType
 */
export interface EntityType {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof EntityType
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityType
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityType
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof EntityType
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof EntityType
     */
    'alias'?: BaseEntityTypeAlias;
    /**
     * 
     * @type {boolean}
     * @memberof EntityType
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityType
     */
    'events'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntityTypeAllEventsSuccessResponse
 */
export interface EntityTypeAllEventsSuccessResponse {
    /**
     * 
     * @type {Error}
     * @memberof EntityTypeAllEventsSuccessResponse
     */
    'error': Error;
    /**
     * 
     * @type {Request}
     * @memberof EntityTypeAllEventsSuccessResponse
     */
    'request': Request;
    /**
     * 
     * @type {EntityTypeAllEventsSuccessResponseAllOfData}
     * @memberof EntityTypeAllEventsSuccessResponse
     */
    'data'?: EntityTypeAllEventsSuccessResponseAllOfData;
}
/**
 * 
 * @export
 * @interface EntityTypeAllEventsSuccessResponseAllOfData
 */
export interface EntityTypeAllEventsSuccessResponseAllOfData {
    /**
     * 
     * @type {Array<StateMachineEventsResponse>}
     * @memberof EntityTypeAllEventsSuccessResponseAllOfData
     */
    'events'?: Array<StateMachineEventsResponse>;
}
/**
 * 
 * @export
 * @interface EntityTypeCallbackElasticData
 */
export interface EntityTypeCallbackElasticData {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackElasticData
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackElasticData
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackElasticData
     */
    'entityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackElasticData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackElasticData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackElasticData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntityTypeCallbackElasticData
     */
    'updatedBy'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityTypeCallbackElasticData
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface EntityTypeCallbackRequest
 */
export interface EntityTypeCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'entityName': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof EntityTypeCallbackRequest
     */
    'schema'?: Array<object>;
    /**
     * 
     * @type {object}
     * @memberof EntityTypeCallbackRequest
     */
    'meta'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeCallbackRequest
     */
    'schemaValidated': boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'requestId': string;
    /**
     * 
     * @type {object}
     * @memberof EntityTypeCallbackRequest
     */
    'callbackMeta'?: object;
    /**
     * 
     * @type {object}
     * @memberof EntityTypeCallbackRequest
     */
    'reason'?: object;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'errorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'commandName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCallbackRequest
     */
    'businessCommand': string;
    /**
     * 
     * @type {EntityTypeCallbackElasticData}
     * @memberof EntityTypeCallbackRequest
     */
    'elasticPayload'?: EntityTypeCallbackElasticData;
}
/**
 * entity type change information.
 * @export
 * @interface EntityTypeChange
 */
export interface EntityTypeChange {
    /**
     * 
     * @type {ChangeAction}
     * @memberof EntityTypeChange
     */
    'action': ChangeAction;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityTypeChange
     */
    'actionTime': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityTypeChange
     */
    'actionBy': ActionBy;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeChange
     */
    'channel': string;
    /**
     * 
     * @type {BaseEntityTypeChange}
     * @memberof EntityTypeChange
     */
    'cdc': BaseEntityTypeChange;
}


/**
 * 
 * @export
 * @interface EntityTypeChangeLogResponse
 */
export interface EntityTypeChangeLogResponse {
    /**
     * 
     * @type {Error}
     * @memberof EntityTypeChangeLogResponse
     */
    'error'?: Error;
    /**
     * 
     * @type {EntityTypeChangeLogResponseData}
     * @memberof EntityTypeChangeLogResponse
     */
    'data'?: EntityTypeChangeLogResponseData;
    /**
     * 
     * @type {Request}
     * @memberof EntityTypeChangeLogResponse
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface EntityTypeChangeLogResponseData
 */
export interface EntityTypeChangeLogResponseData {
    /**
     * 
     * @type {TemplatesResponseDataMeta}
     * @memberof EntityTypeChangeLogResponseData
     */
    'meta'?: TemplatesResponseDataMeta;
    /**
     * 
     * @type {Array<EntityTypeChange>}
     * @memberof EntityTypeChangeLogResponseData
     */
    'log'?: Array<EntityTypeChange>;
}
/**
 * 
 * @export
 * @interface EntityTypeCreateCallbackResponse
 */
export interface EntityTypeCreateCallbackResponse {
    /**
     * tenant id.
     * @type {string}
     * @memberof EntityTypeCreateCallbackResponse
     */
    'tenantId'?: string;
    /**
     * entity type.
     * @type {string}
     * @memberof EntityTypeCreateCallbackResponse
     */
    'EntityType'?: string;
    /**
     * entity type id.
     * @type {string}
     * @memberof EntityTypeCreateCallbackResponse
     */
    'EntityTypePluralName'?: string;
    /**
     * status of entity type creation.
     * @type {string}
     * @memberof EntityTypeCreateCallbackResponse
     */
    'status'?: string;
    /**
     * failure reason in case of entity type creation failed.
     * @type {string}
     * @memberof EntityTypeCreateCallbackResponse
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface EntityTypeCreateSchema
 */
export interface EntityTypeCreateSchema {
    /**
     * 
     * @type {EntityTypeCreateSchemaName}
     * @memberof EntityTypeCreateSchema
     */
    'name': EntityTypeCreateSchemaName;
    /**
     * 
     * @type {EntityTypeCreateSchemaAlias}
     * @memberof EntityTypeCreateSchema
     */
    'alias'?: EntityTypeCreateSchemaAlias;
    /**
     * 
     * @type {Array<Category>}
     * @memberof EntityTypeCreateSchema
     */
    'category'?: Array<Category>;
    /**
     * 
     * @type {Array<AttributeConfig>}
     * @memberof EntityTypeCreateSchema
     */
    'attributes'?: Array<AttributeConfig>;
    /**
     * 
     * @type {Array<CoreAttributeConfig>}
     * @memberof EntityTypeCreateSchema
     */
    'coreAttributes'?: Array<CoreAttributeConfig>;
    /**
     * 
     * @type {CallbackMeta}
     * @memberof EntityTypeCreateSchema
     */
    'callback'?: CallbackMeta;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeCreateSchema
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityTypeCreateSchema
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeCreateSchema
     */
    'entityCode'?: string;
}
/**
 * 
 * @export
 * @interface EntityTypeCreateSchemaAlias
 */
export interface EntityTypeCreateSchemaAlias {
    /**
     * plural alias name of entity-type
     * @type {string}
     * @memberof EntityTypeCreateSchemaAlias
     */
    'plural': string;
    /**
     * singular alias name of entity-type
     * @type {string}
     * @memberof EntityTypeCreateSchemaAlias
     */
    'singular': string;
}
/**
 * 
 * @export
 * @interface EntityTypeCreateSchemaName
 */
export interface EntityTypeCreateSchemaName {
    /**
     * plural name of entity-type
     * @type {string}
     * @memberof EntityTypeCreateSchemaName
     */
    'plural': string;
    /**
     * singular name of entity-type
     * @type {string}
     * @memberof EntityTypeCreateSchemaName
     */
    'singular': string;
}
/**
 * Readonly properties of entity type
 * @export
 * @interface EntityTypeReadOnlyProperties
 */
export interface EntityTypeReadOnlyProperties {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof EntityTypeReadOnlyProperties
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeReadOnlyProperties
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeReadOnlyProperties
     */
    'isDeleted'?: boolean;
}
/**
 * Readonly properties of entity type
 * @export
 * @interface EntityTypeReadOnlyWithoutIdProperties
 */
export interface EntityTypeReadOnlyWithoutIdProperties {
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeReadOnlyWithoutIdProperties
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeReadOnlyWithoutIdProperties
     */
    'isDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface EntityTypeResponse
 */
export interface EntityTypeResponse {
    /**
     * 
     * @type {EntityTypeResponseDataGet}
     * @memberof EntityTypeResponse
     */
    'data': EntityTypeResponseDataGet;
    /**
     * 
     * @type {Request}
     * @memberof EntityTypeResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface EntityTypeResponseData
 */
export interface EntityTypeResponseData {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseData
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseData
     */
    'ownerAppId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeResponseData
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeResponseData
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof EntityTypeResponseData
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof EntityTypeResponseData
     */
    'alias'?: BaseEntityTypeAlias;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeResponseData
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseData
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityTypeResponseData
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {Array<AttributeConfigGet>}
     * @memberof EntityTypeResponseData
     */
    'attributes'?: Array<AttributeConfigGet>;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityTypeResponseData
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityTypeResponseData
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityTypeResponseData
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityTypeResponseData
     */
    'updatedBy'?: ActionBy;
    /**
     * 
     * @type {Array<Category>}
     * @memberof EntityTypeResponseData
     */
    'category': Array<Category>;
    /**
     * 
     * @type {Array<CoreAttributeConfig>}
     * @memberof EntityTypeResponseData
     */
    'coreAttributes'?: Array<CoreAttributeConfig>;
}
/**
 * 
 * @export
 * @interface EntityTypeResponseDataGet
 */
export interface EntityTypeResponseDataGet {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseDataGet
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseDataGet
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseDataGet
     */
    'ownerAppId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeResponseDataGet
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeResponseDataGet
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof EntityTypeResponseDataGet
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof EntityTypeResponseDataGet
     */
    'alias'?: BaseEntityTypeAlias;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeResponseDataGet
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeResponseDataGet
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityTypeResponseDataGet
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {Array<AttributesByTag>}
     * @memberof EntityTypeResponseDataGet
     */
    'coreAttributesByTag'?: Array<AttributesByTag>;
    /**
     * 
     * @type {Array<AttributeConfigGet>}
     * @memberof EntityTypeResponseDataGet
     */
    'attributes'?: Array<AttributeConfigGet>;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityTypeResponseDataGet
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityTypeResponseDataGet
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof EntityTypeResponseDataGet
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof EntityTypeResponseDataGet
     */
    'updatedBy'?: ActionBy;
    /**
     * 
     * @type {Array<Category>}
     * @memberof EntityTypeResponseDataGet
     */
    'category': Array<Category>;
    /**
     * 
     * @type {Array<CoreAttributeConfig>}
     * @memberof EntityTypeResponseDataGet
     */
    'coreAttributes'?: Array<CoreAttributeConfig>;
}
/**
 * 
 * @export
 * @interface EntityTypeSuccessResponse
 */
export interface EntityTypeSuccessResponse {
    /**
     * 
     * @type {EntityTypeSuccessResponseAllOfData}
     * @memberof EntityTypeSuccessResponse
     */
    'data': EntityTypeSuccessResponseAllOfData;
    /**
     * 
     * @type {Request}
     * @memberof EntityTypeSuccessResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface EntityTypeSuccessResponseAllOfData
 */
export interface EntityTypeSuccessResponseAllOfData {
    /**
     * A unique *plural name* i.e. a term that defines multiple Entities of this entity type. This is used as collection name in resource URL for this entity type and as Entity id prefix.
     * @type {string}
     * @memberof EntityTypeSuccessResponseAllOfData
     */
    'name'?: string;
}
/**
 * Update entity type configuration
 * @export
 * @interface EntityTypeUpdateRequest
 */
export interface EntityTypeUpdateRequest {
    /**
     * 
     * @type {Array<Category>}
     * @memberof EntityTypeUpdateRequest
     */
    'category'?: Array<Category>;
    /**
     * 
     * @type {Array<CoreAttributeConfig>}
     * @memberof EntityTypeUpdateRequest
     */
    'coreAttributes'?: Array<CoreAttributeConfig>;
    /**
     * 
     * @type {Array<AttributeConfig>}
     * @memberof EntityTypeUpdateRequest
     */
    'attributes'?: Array<AttributeConfig>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityTypeUpdateRequest
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {EntityTypeCreateSchemaAlias}
     * @memberof EntityTypeUpdateRequest
     */
    'alias'?: EntityTypeCreateSchemaAlias;
    /**
     * 
     * @type {CallbackMeta}
     * @memberof EntityTypeUpdateRequest
     */
    'callback'?: CallbackMeta;
}
/**
 * Entity Type
 * @export
 * @interface EntityTypeWithoutId
 */
export interface EntityTypeWithoutId {
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeWithoutId
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeWithoutId
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {BaseEntityTypeName}
     * @memberof EntityTypeWithoutId
     */
    'name': BaseEntityTypeName;
    /**
     * 
     * @type {BaseEntityTypeAlias}
     * @memberof EntityTypeWithoutId
     */
    'alias'?: BaseEntityTypeAlias;
    /**
     * 
     * @type {boolean}
     * @memberof EntityTypeWithoutId
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeWithoutId
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityTypeWithoutId
     */
    'events'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntityTypesResponse
 */
export interface EntityTypesResponse {
    /**
     * 
     * @type {EntityTypesResponseData}
     * @memberof EntityTypesResponse
     */
    'data': EntityTypesResponseData;
    /**
     * 
     * @type {Request}
     * @memberof EntityTypesResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface EntityTypesResponseData
 */
export interface EntityTypesResponseData {
    /**
     * 
     * @type {TemplatesResponseDataMeta}
     * @memberof EntityTypesResponseData
     */
    'meta'?: TemplatesResponseDataMeta;
    /**
     * 
     * @type {Array<EntityTypeResponseData>}
     * @memberof EntityTypesResponseData
     */
    'entityTypes'?: Array<EntityTypeResponseData>;
}
/**
 * 
 * @export
 * @interface EntityUpdateRequest
 */
export interface EntityUpdateRequest {
    /**
     * 
     * @type {object}
     * @memberof EntityUpdateRequest
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof EntityUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EntityUpdateRequest
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUpdateRequest
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUpdateRequest
     */
    'subCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityUpdateRequest
     */
    'templateId'?: string;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof EntityUpdateRequest
     */
    'callback'?: CallbackForInstance;
    /**
     * 
     * @type {CustomCallRequestObject}
     * @memberof EntityUpdateRequest
     */
    'onRequest'?: CustomCallRequestObject;
    /**
     * 
     * @type {CustomCallErrorObject}
     * @memberof EntityUpdateRequest
     */
    'onError'?: CustomCallErrorObject;
    /**
     * expiry datetime in epoch (sec) (> current date and < 6 months from current date)
     * @type {number}
     * @memberof EntityUpdateRequest
     */
    'TTL'?: number | null;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Error}
     * @memberof ErrorResponse
     */
    'error': Error;
    /**
     * 
     * @type {Request}
     * @memberof ErrorResponse
     */
    'request': Request;
}
/**
 * Event for state transition
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Event Code of the format:E-xxx. E - Prefix indicating that this is an event code. xxx - 3 digit event code string ranging from 001 to 999
     * @type {string}
     * @memberof Event
     */
    'eventCode': string;
    /**
     * Reason Code of the format:R-nnnn R - Prefix indicating that this is a reason code nnnn - 4 digit reason code string ranging from 0001 to 9999
     * @type {string}
     * @memberof Event
     */
    'reasonCode'?: string;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof Event
     */
    'timestamp'?: number;
    /**
     * Represents event data values, if any, for this event
     * @type {object}
     * @memberof Event
     */
    'data'?: object;
    /**
     * 
     * @type {EventSource}
     * @memberof Event
     */
    'source'?: EventSource;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof Event
     */
    'callback'?: CallbackForInstance;
}
/**
 * Create event
 * @export
 * @interface EventCreateRequest
 */
export interface EventCreateRequest {
    /**
     * Short description of the event. Max length 64 characters.
     * @type {string}
     * @memberof EventCreateRequest
     */
    'description': string;
    /**
     * 
     * @type {EventType}
     * @memberof EventCreateRequest
     */
    'eventType'?: EventType;
    /**
     * List of valid reason codes that can raise this event code
     * @type {Array<string>}
     * @memberof EventCreateRequest
     */
    'reasonCodes'?: Array<string>;
    /**
     * List of valid current states of the entity when this event code can be applied.
     * @type {Array<string>}
     * @memberof EventCreateRequest
     */
    'validCurrentStates'?: Array<string>;
    /**
     * True - Event Code is valid & usable. False - Event Code is not usable
     * @type {boolean}
     * @memberof EventCreateRequest
     */
    'isEnabled'?: boolean;
    /**
     * Data expected along with the event and their respective validations, if any.
     * @type {Array<EventDataItem>}
     * @memberof EventCreateRequest
     */
    'dataValidations'?: Array<EventDataItem>;
}


/**
 * 
 * @export
 * @interface EventDataItem
 */
export interface EventDataItem {
    /**
     * Name of validation keys of an event.
     * @type {string}
     * @memberof EventDataItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventDataItem
     */
    'description'?: string;
    /**
     * 
     * @type {DataType}
     * @memberof EventDataItem
     */
    'type': DataType;
    /**
     * 
     * @type {EventDataValidation}
     * @memberof EventDataItem
     */
    'validation'?: EventDataValidation;
}


/**
 * 
 * @export
 * @interface EventDataValidation
 */
export interface EventDataValidation {
    /**
     * 
     * @type {Range}
     * @memberof EventDataValidation
     */
    'range'?: Range;
    /**
     * Regex pattern that the string type data should match
     * @type {string}
     * @memberof EventDataValidation
     */
    'regex'?: string;
    /**
     * Enum of accepted values
     * @type {Array<ValidationValueOneOfInner>}
     * @memberof EventDataValidation
     */
    'valueOneOf'?: Array<ValidationValueOneOfInner>;
    /**
     * Specifies whether the value is required or optional
     * @type {boolean}
     * @memberof EventDataValidation
     */
    'required': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventDataValidation
     */
    'blocking'?: boolean;
}
/**
 * Represents the source which triggered the event. It can be an app, a user or some location from where the event was triggered.
 * @export
 * @interface EventSource
 */
export interface EventSource {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof EventSource
     */
    'appId': string;
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof EventSource
     */
    'userId'?: string;
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof EventSource
     */
    'locId'?: string;
}
/**
 * Specifies event is transitional or not.
 * @export
 * @enum {string}
 */

export const EventType = {
    Transitional: 'TRANSITIONAL',
    NonTransitional: 'NON_TRANSITIONAL'
} as const;

export type EventType = typeof EventType[keyof typeof EventType];


/**
 * Update event
 * @export
 * @interface EventUpdateRequest
 */
export interface EventUpdateRequest {
    /**
     * Short description of the event. Max length 64 characters.
     * @type {string}
     * @memberof EventUpdateRequest
     */
    'description': string;
    /**
     * 
     * @type {EventType}
     * @memberof EventUpdateRequest
     */
    'eventType'?: EventType;
    /**
     * List of valid reason codes that can raise this event code
     * @type {Array<string>}
     * @memberof EventUpdateRequest
     */
    'reasonCodes'?: Array<string>;
    /**
     * List of valid current states of the entity when this event code can be applied.
     * @type {Array<string>}
     * @memberof EventUpdateRequest
     */
    'validCurrentStates'?: Array<string>;
    /**
     * True - Event Code is valid & usable. False - Event Code is not usable
     * @type {boolean}
     * @memberof EventUpdateRequest
     */
    'isEnabled'?: boolean;
    /**
     * Data expected along with the event and their respective validations, if any.
     * @type {Array<EventDataItem>}
     * @memberof EventUpdateRequest
     */
    'dataValidations'?: Array<EventDataItem>;
}


/**
 * Event description. Contains event name, event data,if any.
 * @export
 * @interface Events
 */
export interface Events {
    /**
     * Represents name of the event for state transition
     * @type {string}
     * @memberof Events
     */
    'event': string;
    /**
     * 
     * @type {EventType}
     * @memberof Events
     */
    'eventType'?: EventType;
    /**
     * Data expected along with the event and their respective validations, if any.
     * @type {Array<EventDataItem>}
     * @memberof Events
     */
    'eventData'?: Array<EventDataItem>;
}


/**
 * geolocation details, it consists lat and long of the location used to save geoloaction of address.
 * @export
 * @interface GeoLocation
 */
export interface GeoLocation {
    /**
     * latitude of the location
     * @type {string}
     * @memberof GeoLocation
     */
    'latitude': string;
    /**
     * longitude of the location
     * @type {string}
     * @memberof GeoLocation
     */
    'longitude': string;
}
/**
 * geo co-ordinates of the location used for geopoint as data type.
 * @export
 * @interface GeoPoint
 */
export interface GeoPoint {
    /**
     * Latitude in degrees. Values should be in the range [-90, 90].
     * @type {number}
     * @memberof GeoPoint
     */
    'lat': number;
    /**
     * Longitude in degrees. Values should be in the range [-180, 180].
     * @type {number}
     * @memberof GeoPoint
     */
    'lon': number;
}
/**
 * 
 * @export
 * @interface GetErrorResponse
 */
export interface GetErrorResponse {
    /**
     * 
     * @type {Error}
     * @memberof GetErrorResponse
     */
    'error': Error;
    /**
     * 
     * @type {Request}
     * @memberof GetErrorResponse
     */
    'request': Request;
    /**
     * 
     * @type {SuccessResponseData}
     * @memberof GetErrorResponse
     */
    'data'?: SuccessResponseData;
}
/**
 * 
 * @export
 * @interface GetSingleEntityResponseData
 */
export interface GetSingleEntityResponseData {
    /**
     * Name of the Entity
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'name'?: string | null;
    /**
     * owner of Entity should be valid Entity id
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'owner': string;
    /**
     * valid entity category
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'category'?: string | null;
    /**
     * valid entity sub category
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'subCategory'?: string | null;
    /**
     * Key-Value representation of all core attributes of the Entity. 
     * @type {object}
     * @memberof GetSingleEntityResponseData
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'entityName': string;
    /**
     * 
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'templateId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'ownerAppId'?: string;
    /**
     * default state in state machine
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'state'?: string | null;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof GetSingleEntityResponseData
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof GetSingleEntityResponseData
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof GetSingleEntityResponseData
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof GetSingleEntityResponseData
     */
    'updatedBy'?: ActionBy;
    /**
     * Unique id of the instance
     * @type {any}
     * @memberof GetSingleEntityResponseData
     */
    'id': any;
    /**
     * 
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'uniqueCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetSingleEntityResponseData
     */
    'isActive'?: boolean;
    /**
     * unique id of entity type
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'entityId'?: string;
    /**
     * TTL (epoch in seconds)
     * @type {number}
     * @memberof GetSingleEntityResponseData
     */
    'TTL'?: number;
    /**
     * URL to notify the outcome of the request.
     * @type {string}
     * @memberof GetSingleEntityResponseData
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface InstanceCDC
 */
export interface InstanceCDC {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof InstanceCDC
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceCDC
     */
    'state': string;
    /**
     * 
     * @type {Event}
     * @memberof InstanceCDC
     */
    'event': Event;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCDC
     */
    'stateChange'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InstanceCDC
     */
    'terminalTTL'?: number;
}
/**
 * Event for state transition
 * @export
 * @interface InstanceCallbackEvent
 */
export interface InstanceCallbackEvent {
    /**
     * Represents name of the event for state transition
     * @type {string}
     * @memberof InstanceCallbackEvent
     */
    'name': string;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof InstanceCallbackEvent
     */
    'timestamp': number;
    /**
     * Represents event data values, if any, for this event
     * @type {object}
     * @memberof InstanceCallbackEvent
     */
    'data': object;
    /**
     * 
     * @type {EventSource}
     * @memberof InstanceCallbackEvent
     */
    'source': EventSource;
}
/**
 * 
 * @export
 * @interface InstanceDefaultState
 */
export interface InstanceDefaultState {
    /**
     * default state in state machine
     * @type {string}
     * @memberof InstanceDefaultState
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface InstanceDefaultStateNullable
 */
export interface InstanceDefaultStateNullable {
    /**
     * default state in state machine
     * @type {string}
     * @memberof InstanceDefaultStateNullable
     */
    'state'?: string | null;
}
/**
 * 
 * @export
 * @interface InstanceState
 */
export interface InstanceState {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof InstanceState
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceState
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface InstanceStateGetResponse
 */
export interface InstanceStateGetResponse {
    /**
     * 
     * @type {InstanceState}
     * @memberof InstanceStateGetResponse
     */
    'data': InstanceState;
    /**
     * 
     * @type {Request}
     * @memberof InstanceStateGetResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface InstanceStateSuccessResponse
 */
export interface InstanceStateSuccessResponse {
    /**
     * 
     * @type {Error}
     * @memberof InstanceStateSuccessResponse
     */
    'error'?: Error;
    /**
     * 
     * @type {InstanceCDC}
     * @memberof InstanceStateSuccessResponse
     */
    'data'?: InstanceCDC;
    /**
     * 
     * @type {Request}
     * @memberof InstanceStateSuccessResponse
     */
    'request'?: Request;
}
/**
 * Destination state for instace state transition.
 * @export
 * @interface InstanceStateUpdateRequest
 */
export interface InstanceStateUpdateRequest {
    /**
     * 
     * @type {CustomCallRequestObject}
     * @memberof InstanceStateUpdateRequest
     */
    'onRequest'?: CustomCallRequestObject;
    /**
     * 
     * @type {CustomCallErrorObject}
     * @memberof InstanceStateUpdateRequest
     */
    'onError'?: CustomCallErrorObject;
    /**
     * Event Code of the format:E-xxx. E - Prefix indicating that this is an event code. xxx - 3 digit event code string ranging from 001 to 999
     * @type {string}
     * @memberof InstanceStateUpdateRequest
     */
    'eventCode': string;
    /**
     * Reason Code of the format:R-nnnn R - Prefix indicating that this is a reason code nnnn - 4 digit reason code string ranging from 0001 to 9999
     * @type {string}
     * @memberof InstanceStateUpdateRequest
     */
    'reasonCode'?: string;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof InstanceStateUpdateRequest
     */
    'timestamp'?: number;
    /**
     * Represents event data values, if any, for this event
     * @type {object}
     * @memberof InstanceStateUpdateRequest
     */
    'data'?: object;
    /**
     * 
     * @type {EventSource}
     * @memberof InstanceStateUpdateRequest
     */
    'source'?: EventSource;
    /**
     * 
     * @type {CallbackForInstance}
     * @memberof InstanceStateUpdateRequest
     */
    'callback'?: CallbackForInstance;
}
/**
 * HTTP method requested on the API endpoint
 * @export
 * @enum {string}
 */

export const Method = {
    Post: 'POST',
    Get: 'GET',
    Put: 'PUT'
} as const;

export type Method = typeof Method[keyof typeof Method];


/**
 * Error Information
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'description'?: string;
    /**
     * Additional information related to the error
     * @type {object}
     * @memberof ModelError
     */
    'additionalInfo'?: object;
}
/**
 * money type data type, which consists amouunt and name of the currency to which country it belongs.
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * code of the currency to which country it belongs.
     * @type {string}
     * @memberof Money
     */
    'currencyCode': string;
    /**
     * amount of the money.
     * @type {number}
     * @memberof Money
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface OnResponseForOnErrorObject
 */
export interface OnResponseForOnErrorObject {
    /**
     * 
     * @type {boolean}
     * @memberof OnResponseForOnErrorObject
     */
    'wait'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof OnResponseForOnErrorObject
     */
    'acceptableStatusCodes'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof OnResponseForOnErrorObject
     */
    'raiseErrorOnStatusMismatch'?: boolean;
}
/**
 * 
 * @export
 * @interface OnResponseObject
 */
export interface OnResponseObject {
    /**
     * 
     * @type {boolean}
     * @memberof OnResponseObject
     */
    'wait': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof OnResponseObject
     */
    'acceptableStatusCodes'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof OnResponseObject
     */
    'raiseErrorOnStatusMismatch'?: boolean;
}
/**
 * ordering of data
 * @export
 * @enum {string}
 */

export const OrderBy = {
    Desc: 'desc',
    Asc: 'asc'
} as const;

export type OrderBy = typeof OrderBy[keyof typeof OrderBy];


/**
 * phone type data type, which consists below fields.
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     * country code of the mobile it belongs.
     * @type {string}
     * @memberof Phone
     */
    'countryCode': string;
    /**
     * user phone number
     * @type {string}
     * @memberof Phone
     */
    'number': string;
    /**
     * whether the phone is of type mobile or telephone.
     * @type {boolean}
     * @memberof Phone
     */
    'isMobile': boolean;
    /**
     * in case of type telephone, areaCode of the telephone it belongs.
     * @type {string}
     * @memberof Phone
     */
    'areaCode'?: string;
}
/**
 * 
 * @export
 * @interface PostErrorResponse
 */
export interface PostErrorResponse {
    /**
     * 
     * @type {Error}
     * @memberof PostErrorResponse
     */
    'error': Error;
    /**
     * 
     * @type {Request}
     * @memberof PostErrorResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface PreconfigureCustomCallObject
 */
export interface PreconfigureCustomCallObject {
    /**
     * request URL for the custom call
     * @type {string}
     * @memberof PreconfigureCustomCallObject
     */
    'url'?: string;
    /**
     * request headers object for custom call
     * @type {object}
     * @memberof PreconfigureCustomCallObject
     */
    'requestHeader'?: object;
    /**
     * request body object for custom call
     * @type {object}
     * @memberof PreconfigureCustomCallObject
     */
    'requestBody'?: object;
    /**
     * 
     * @type {Method}
     * @memberof PreconfigureCustomCallObject
     */
    'method'?: Method;
    /**
     * 
     * @type {boolean}
     * @memberof PreconfigureCustomCallObject
     */
    'wait'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof PreconfigureCustomCallObject
     */
    'acceptableStatusCodes'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof PreconfigureCustomCallObject
     */
    'raiseErrorOnStatusMismatch'?: boolean;
}


/**
 * 
 * @export
 * @interface PutErrorResponse
 */
export interface PutErrorResponse {
    /**
     * 
     * @type {Error}
     * @memberof PutErrorResponse
     */
    'error': Error;
    /**
     * 
     * @type {Request}
     * @memberof PutErrorResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'match'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'multi_match'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'term'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'terms'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'range'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'regexp'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'exists'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'match_phrase'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'match_phrase_prefix'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'prefix'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Query
     */
    'fuzzy'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Query2
 */
export interface Query2 {
    /**
     * 
     * @type {Array<object>}
     * @memberof Query2
     */
    'arr'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Query2
     */
    'op'?: string;
}
/**
 * Minimum & maximum values if data type is number. Minimum and maximum length if data type is string
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {number}
     * @memberof Range
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof Range
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * The API end point where the request was received
     * @type {string}
     * @memberof Request
     */
    'uri': string;
    /**
     * HTTP method requested on the API endpoint
     * @type {string}
     * @memberof Request
     */
    'method'?: RequestMethodEnum;
    /**
     * Query string received by the server
     * @type {string}
     * @memberof Request
     */
    'queryString'?: string;
    /**
     * Request body data received by the server
     * @type {object}
     * @memberof Request
     */
    'body'?: object;
}

export const RequestMethodEnum = {
    Post: 'POST',
    Get: 'GET',
    Put: 'PUT'
} as const;

export type RequestMethodEnum = typeof RequestMethodEnum[keyof typeof RequestMethodEnum];

/**
 * 
 * @export
 * @interface State
 */
export interface State {
    /**
     * Name of the state
     * @type {string}
     * @memberof State
     */
    'name': string;
    /**
     * Name of the state
     * @type {string}
     * @memberof State
     */
    'defaultSubState': string;
    /**
     * 
     * @type {Array<SubState>}
     * @memberof State
     */
    'subStates': Array<SubState>;
    /**
     * Represents terminal state list for this state. Only the last main state should have terminal states.
     * @type {Array<string>}
     * @memberof State
     */
    'terminalStates'?: Array<string>;
}
/**
 * Entity type state-machine configuration
 * @export
 * @interface StateMachineConfig
 */
export interface StateMachineConfig {
    /**
     * List of main states with its substates and transitions
     * @type {Array<State>}
     * @memberof StateMachineConfig
     */
    'states': Array<State>;
    /**
     * Time to live. Time string in days, hours, minutes and seconds. Example - 30m, 1d 12h, 1d 12h 30m 45s etc.
     * @type {string}
     * @memberof StateMachineConfig
     */
    'terminalTTL'?: string;
    /**
     * Represents callback url, which can be called to get any info about state transition of an instance.
     * @type {string}
     * @memberof StateMachineConfig
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface StateMachineConfigResponse
 */
export interface StateMachineConfigResponse {
    /**
     * 
     * @type {StateMachineConfigResponseData}
     * @memberof StateMachineConfigResponse
     */
    'data': StateMachineConfigResponseData;
    /**
     * 
     * @type {Request}
     * @memberof StateMachineConfigResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface StateMachineConfigResponseData
 */
export interface StateMachineConfigResponseData {
    /**
     * List of main states with its substates and transitions
     * @type {Array<State>}
     * @memberof StateMachineConfigResponseData
     */
    'states': Array<State>;
    /**
     * Time to live. Time string in days, hours, minutes and seconds. Example - 30m, 1d 12h, 1d 12h 30m 45s etc.
     * @type {string}
     * @memberof StateMachineConfigResponseData
     */
    'terminalTTL'?: string;
    /**
     * Represents callback url, which can be called to get any info about state transition of an instance.
     * @type {string}
     * @memberof StateMachineConfigResponseData
     */
    'callback'?: string;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof StateMachineConfigResponseData
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof StateMachineConfigResponseData
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof StateMachineConfigResponseData
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof StateMachineConfigResponseData
     */
    'updatedBy'?: ActionBy;
    /**
     * entity type id.
     * @type {string}
     * @memberof StateMachineConfigResponseData
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StateMachineEventsResponse
 */
export interface StateMachineEventsResponse {
    /**
     * Short description of the event. Max length 64 characters.
     * @type {string}
     * @memberof StateMachineEventsResponse
     */
    'description'?: string;
    /**
     * 
     * @type {EventType}
     * @memberof StateMachineEventsResponse
     */
    'eventType'?: EventType;
    /**
     * List of valid reason codes that can raise this event code
     * @type {Array<string>}
     * @memberof StateMachineEventsResponse
     */
    'reasonCodes'?: Array<string>;
    /**
     * List of valid current states of the entity when this event code can be applied.
     * @type {Array<string>}
     * @memberof StateMachineEventsResponse
     */
    'validCurrentStates'?: Array<string>;
    /**
     * True - Event Code is valid & usable. False - Event Code is not usable
     * @type {boolean}
     * @memberof StateMachineEventsResponse
     */
    'isEnabled'?: boolean;
    /**
     * Data expected along with the event and their respective validations, if any.
     * @type {Array<EventDataItem>}
     * @memberof StateMachineEventsResponse
     */
    'dataValidations'?: Array<EventDataItem>;
    /**
     * event code.
     * @type {string}
     * @memberof StateMachineEventsResponse
     */
    'eventCode'?: string;
}


/**
 * 
 * @export
 * @interface StateMachineEventsSuccessResponse
 */
export interface StateMachineEventsSuccessResponse {
    /**
     * 
     * @type {Error}
     * @memberof StateMachineEventsSuccessResponse
     */
    'error': Error;
    /**
     * 
     * @type {Request}
     * @memberof StateMachineEventsSuccessResponse
     */
    'request': Request;
    /**
     * 
     * @type {StateMachineEventsResponse}
     * @memberof StateMachineEventsSuccessResponse
     */
    'data'?: StateMachineEventsResponse;
}
/**
 * State Machine properties of entity type
 * @export
 * @interface StateMachineProperties
 */
export interface StateMachineProperties {
    /**
     * 
     * @type {boolean}
     * @memberof StateMachineProperties
     */
    'isStateMachineEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StateMachineProperties
     */
    'stateMachineEntityCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StateMachineProperties
     */
    'events'?: Array<string>;
}
/**
 * Update state machine config
 * @export
 * @interface StateMachineRequest
 */
export interface StateMachineRequest {
    /**
     * List of main states with its substates and transitions
     * @type {Array<State>}
     * @memberof StateMachineRequest
     */
    'states': Array<State>;
    /**
     * Time to live. Time string in days, hours, minutes and seconds. Example - 30m, 1d 12h, 1d 12h 30m 45s etc.
     * @type {string}
     * @memberof StateMachineRequest
     */
    'terminalTTL'?: string;
    /**
     * Represents callback url, which can be called to get any info about state transition of an instance.
     * @type {string}
     * @memberof StateMachineRequest
     */
    'callback'?: string;
}
/**
 * Time to live associated with each state of an instance
 * @export
 * @interface StateTTL
 */
export interface StateTTL {
    /**
     * Time to live. Time string in days, hours, minutes and seconds. Example - 30m, 1d 12h, 1d 12h 30m 45s etc.
     * @type {string}
     * @memberof StateTTL
     */
    'time': string;
    /**
     * Name of the main state and its substate
     * @type {string}
     * @memberof StateTTL
     */
    'destination': string;
}
/**
 * Transition Rule for this state. Contains event and the destination state.
 * @export
 * @interface StateTransitionRule
 */
export interface StateTransitionRule {
    /**
     * Event Code of the format:E-xxx. E - Prefix indicating that this is an event code. xxx - 3 digit event code string ranging from 001 to 999
     * @type {string}
     * @memberof StateTransitionRule
     */
    'eventCode': string;
    /**
     * Name of the main state and its substate
     * @type {string}
     * @memberof StateTransitionRule
     */
    'destination': string;
    /**
     * Reason Code of the format:R-nnnn R - Prefix indicating that this is a reason code nnnn - 4 digit reason code string ranging from 0001 to 9999
     * @type {string}
     * @memberof StateTransitionRule
     */
    'reasonCode'?: string;
}
/**
 * 
 * @export
 * @interface SubState
 */
export interface SubState {
    /**
     * Name of the state
     * @type {string}
     * @memberof SubState
     */
    'name': string;
    /**
     * Represents array of transition rules for this substate
     * @type {Array<StateTransitionRule>}
     * @memberof SubState
     */
    'transitions': Array<StateTransitionRule>;
    /**
     * 
     * @type {StateTTL}
     * @memberof SubState
     */
    'ttl'?: StateTTL;
    /**
     * Represents callback url, which can be called to get any info about state transition of an instance.
     * @type {string}
     * @memberof SubState
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface SuccessMockResponse
 */
export interface SuccessMockResponse {
    /**
     * 
     * @type {Request}
     * @memberof SuccessMockResponse
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {SuccessResponseData}
     * @memberof SuccessResponse
     */
    'data': SuccessResponseData;
    /**
     * 
     * @type {Request}
     * @memberof SuccessResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface SuccessResponseData
 */
export interface SuccessResponseData {
    /**
     * Unique ID. Combination of entity name and UUID.
     * @type {string}
     * @memberof SuccessResponseData
     */
    'id'?: string;
}
/**
 * entity template definition
 * @export
 * @interface TemplateAttributeConfig
 */
export interface TemplateAttributeConfig {
    /**
     * template name.
     * @type {string}
     * @memberof TemplateAttributeConfig
     */
    'name': string;
    /**
     * entity category from the list of valid entity categories.
     * @type {string}
     * @memberof TemplateAttributeConfig
     */
    'category': string;
    /**
     * entity sub category from the list of valid entity sub categories.
     * @type {string}
     * @memberof TemplateAttributeConfig
     */
    'subCategory': string;
    /**
     * 
     * @type {Array<AttributeConfigTemplate>}
     * @memberof TemplateAttributeConfig
     */
    'attributes': Array<AttributeConfigTemplate>;
}
/**
 * entity template definition
 * @export
 * @interface TemplateAttributeConfigGet
 */
export interface TemplateAttributeConfigGet {
    /**
     * template name.
     * @type {string}
     * @memberof TemplateAttributeConfigGet
     */
    'name': string;
    /**
     * entity category from the list of valid entity categories.
     * @type {string}
     * @memberof TemplateAttributeConfigGet
     */
    'category': string;
    /**
     * entity sub category from the list of valid entity sub categories.
     * @type {string}
     * @memberof TemplateAttributeConfigGet
     */
    'subCategory': string;
    /**
     * 
     * @type {Array<AttributeConfigGet>}
     * @memberof TemplateAttributeConfigGet
     */
    'attributes': Array<AttributeConfigGet>;
}
/**
 * 
 * @export
 * @interface TemplateCreateRequest
 */
export interface TemplateCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateRequest
     */
    'subCategory': string;
    /**
     * 
     * @type {Array<AttributeConfigTemplate>}
     * @memberof TemplateCreateRequest
     */
    'attributes'?: Array<AttributeConfigTemplate>;
    /**
     * 
     * @type {CallbackMeta}
     * @memberof TemplateCreateRequest
     */
    'callback'?: CallbackMeta;
}
/**
 * 
 * @export
 * @interface TemplateResponse
 */
export interface TemplateResponse {
    /**
     * 
     * @type {TemplateResponseDataGet}
     * @memberof TemplateResponse
     */
    'data': TemplateResponseDataGet;
    /**
     * 
     * @type {Request}
     * @memberof TemplateResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface TemplateResponseData
 */
export interface TemplateResponseData {
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseData
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseData
     */
    'ownerAppId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseData
     */
    'entityName': string;
    /**
     * template name.
     * @type {string}
     * @memberof TemplateResponseData
     */
    'name': string;
    /**
     * entity category from the list of valid entity categories.
     * @type {string}
     * @memberof TemplateResponseData
     */
    'category': string;
    /**
     * entity sub category from the list of valid entity sub categories.
     * @type {string}
     * @memberof TemplateResponseData
     */
    'subCategory': string;
    /**
     * 
     * @type {Array<AttributeConfigTemplate>}
     * @memberof TemplateResponseData
     */
    'attributes': Array<AttributeConfigTemplate>;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof TemplateResponseData
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof TemplateResponseData
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof TemplateResponseData
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof TemplateResponseData
     */
    'updatedBy'?: ActionBy;
    /**
     * Unique id of the template
     * @type {any}
     * @memberof TemplateResponseData
     */
    'id'?: any;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseData
     */
    'entityId'?: string;
    /**
     * URL to notify the outcome of the request.
     * @type {string}
     * @memberof TemplateResponseData
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface TemplateResponseDataGet
 */
export interface TemplateResponseDataGet {
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'ownerAppId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'entityName': string;
    /**
     * template name.
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'name': string;
    /**
     * entity category from the list of valid entity categories.
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'category': string;
    /**
     * entity sub category from the list of valid entity sub categories.
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'subCategory': string;
    /**
     * 
     * @type {Array<AttributeConfigGet>}
     * @memberof TemplateResponseDataGet
     */
    'attributes': Array<AttributeConfigGet>;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof TemplateResponseDataGet
     */
    'createdAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof TemplateResponseDataGet
     */
    'createdBy'?: ActionBy;
    /**
     * Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
     * @type {number}
     * @memberof TemplateResponseDataGet
     */
    'updatedAt': number;
    /**
     * 
     * @type {ActionBy}
     * @memberof TemplateResponseDataGet
     */
    'updatedBy'?: ActionBy;
    /**
     * Unique id of the template
     * @type {any}
     * @memberof TemplateResponseDataGet
     */
    'id'?: any;
    /**
     * 
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'entityId'?: string;
    /**
     * 
     * @type {Array<AttributesByTag>}
     * @memberof TemplateResponseDataGet
     */
    'attributesByTag'?: Array<AttributesByTag>;
    /**
     * URL to notify the outcome of the request.
     * @type {string}
     * @memberof TemplateResponseDataGet
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface TemplateResponseSchema
 */
export interface TemplateResponseSchema {
    /**
     * template name.
     * @type {string}
     * @memberof TemplateResponseSchema
     */
    'name': string;
    /**
     * entity category from the list of valid entity categories.
     * @type {string}
     * @memberof TemplateResponseSchema
     */
    'category': string;
    /**
     * entity sub category from the list of valid entity sub categories.
     * @type {string}
     * @memberof TemplateResponseSchema
     */
    'subCategory': string;
    /**
     * 
     * @type {Array<AttributeConfigTemplate>}
     * @memberof TemplateResponseSchema
     */
    'attributes': Array<AttributeConfigTemplate>;
    /**
     * Unique id of the template
     * @type {any}
     * @memberof TemplateResponseSchema
     */
    'id'?: any;
}
/**
 * 
 * @export
 * @interface TemplateUpdateRequest
 */
export interface TemplateUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplateUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<AttributeConfigTemplate>}
     * @memberof TemplateUpdateRequest
     */
    'attributes'?: Array<AttributeConfigTemplate>;
    /**
     * 
     * @type {CallbackMeta}
     * @memberof TemplateUpdateRequest
     */
    'callback'?: CallbackMeta;
}
/**
 * 
 * @export
 * @interface TemplatesResponse
 */
export interface TemplatesResponse {
    /**
     * 
     * @type {TemplatesResponseData}
     * @memberof TemplatesResponse
     */
    'data': TemplatesResponseData;
    /**
     * 
     * @type {Request}
     * @memberof TemplatesResponse
     */
    'request': Request;
}
/**
 * 
 * @export
 * @interface TemplatesResponseData
 */
export interface TemplatesResponseData {
    /**
     * 
     * @type {TemplatesResponseDataMeta}
     * @memberof TemplatesResponseData
     */
    'meta'?: TemplatesResponseDataMeta;
    /**
     * 
     * @type {Array<TemplateResponseData>}
     * @memberof TemplatesResponseData
     */
    'entityTemplates'?: Array<TemplateResponseData>;
}
/**
 * 
 * @export
 * @interface TemplatesResponseDataMeta
 */
export interface TemplatesResponseDataMeta {
    /**
     * 
     * @type {number}
     * @memberof TemplatesResponseDataMeta
     */
    'totalElements'?: number;
}
/**
 * Validation rules for a string or number value
 * @export
 * @interface Validation
 */
export interface Validation {
    /**
     * 
     * @type {Range}
     * @memberof Validation
     */
    'range'?: Range;
    /**
     * Regex pattern that the string type data should match
     * @type {string}
     * @memberof Validation
     */
    'regex'?: string;
    /**
     * Enum of accepted values
     * @type {Array<ValidationValueOneOfInner>}
     * @memberof Validation
     */
    'valueOneOf'?: Array<ValidationValueOneOfInner>;
    /**
     * Specifies whether the value is required or optional
     * @type {boolean}
     * @memberof Validation
     */
    'required': boolean;
}
/**
 * 
 * @export
 * @interface ValidationValueOneOfInner
 */
export interface ValidationValueOneOfInner {
}

/**
 * EntityBatchProcessingApi - axios parameter creator
 * @export
 */
export const EntityBatchProcessingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchRequest: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('createBatchRequest', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('createBatchRequest', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('createBatchRequest', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('createBatchRequest', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createBatchRequest', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('createBatchRequest', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityBatchCreateRequest' is not null or undefined
            assertParamExists('createBatchRequest', 'entityBatchCreateRequest', entityBatchCreateRequest)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/batch`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityBatchCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchRequestWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityBatchCreateRequest' is not null or undefined
            assertParamExists('createBatchRequestWithoutAppId', 'entityBatchCreateRequest', entityBatchCreateRequest)
            const localVarPath = `/{entityTypePluralName}/batch`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityBatchCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
         * @summary Get the status of batch request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfBatchRequest: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getStatusOfBatchRequest', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getStatusOfBatchRequest', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getStatusOfBatchRequest', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getStatusOfBatchRequest', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getStatusOfBatchRequest', 'batchId', batchId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getStatusOfBatchRequest', 'appId', appId)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/batch/status`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
         * @summary Get the status of batch request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfBatchRequestWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getStatusOfBatchRequestWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getStatusOfBatchRequestWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getStatusOfBatchRequestWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getStatusOfBatchRequestWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getStatusOfBatchRequestWithoutAppId', 'batchId', batchId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getStatusOfBatchRequestWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/{entityTypePluralName}/batch/status`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
         * @summary Get the status of batch file request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfRecordFileUploadRequest: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequest', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequest', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequest', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequest', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequest', 'batchId', batchId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequest', 'appId', appId)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/upload/status`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
         * @summary Get the status of batch file request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfRecordFileUploadRequestWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequestWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequestWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequestWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequestWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequestWithoutAppId', 'batchId', batchId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getStatusOfRecordFileUploadRequestWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/{entityTypePluralName}/upload/status`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (batchId !== undefined) {
                localVarQueryParameter['batchId'] = batchId;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadCreateRequest: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityDataFileUpdateRequest' is not null or undefined
            assertParamExists('recordFileUploadCreateRequest', 'entityDataFileUpdateRequest', entityDataFileUpdateRequest)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/upload`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityDataFileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadCreateRequestWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityDataFileUpdateRequest' is not null or undefined
            assertParamExists('recordFileUploadCreateRequestWithoutAppId', 'entityDataFileUpdateRequest', entityDataFileUpdateRequest)
            const localVarPath = `/{entityTypePluralName}/upload`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityDataFileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update Entities in batch through CSV file upload.** 
         * @summary Perform update operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadUpdateRequest: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityDataFileUpdateRequest' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequest', 'entityDataFileUpdateRequest', entityDataFileUpdateRequest)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/upload`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityDataFileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update Entities in batch through CSV file upload.** 
         * @summary Perform update operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadUpdateRequestWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityDataFileUpdateRequest' is not null or undefined
            assertParamExists('recordFileUploadUpdateRequestWithoutAppId', 'entityDataFileUpdateRequest', entityDataFileUpdateRequest)
            const localVarPath = `/{entityTypePluralName}/upload`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityDataFileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
         * @summary Perform update operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchRequest: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateBatchRequest', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateBatchRequest', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateBatchRequest', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateBatchRequest', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateBatchRequest', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('updateBatchRequest', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityBatchUpdateRequest' is not null or undefined
            assertParamExists('updateBatchRequest', 'entityBatchUpdateRequest', entityBatchUpdateRequest)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/batch`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityBatchUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
         * @summary Perform update operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchRequestWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityBatchUpdateRequest' is not null or undefined
            assertParamExists('updateBatchRequestWithoutAppId', 'entityBatchUpdateRequest', entityBatchUpdateRequest)
            const localVarPath = `/{entityTypePluralName}/batch`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityBatchUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityBatchProcessingApi - functional programming interface
 * @export
 */
export const EntityBatchProcessingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityBatchProcessingApiAxiosParamCreator(configuration)
    return {
        /**
         * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityBatchCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.createBatchRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityBatchCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.createBatchRequestWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
         * @summary Get the status of batch request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusOfBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusOfBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, appId, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.getStatusOfBatchRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
         * @summary Get the status of batch request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusOfBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusOfBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, xCOREOSAPPID, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.getStatusOfBatchRequestWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
         * @summary Get the status of batch file request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusOfRecordFileUploadRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusOfRecordFileUploadRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, appId, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.getStatusOfRecordFileUploadRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
         * @summary Get the status of batch file request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusOfRecordFileUploadRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityBatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusOfRecordFileUploadRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, xCOREOSAPPID, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.getStatusOfRecordFileUploadRequestWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordFileUploadCreateRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordFileUploadCreateRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.recordFileUploadCreateRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordFileUploadCreateRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordFileUploadCreateRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.recordFileUploadCreateRequestWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update Entities in batch through CSV file upload.** 
         * @summary Perform update operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordFileUploadUpdateRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordFileUploadUpdateRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.recordFileUploadUpdateRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update Entities in batch through CSV file upload.** 
         * @summary Perform update operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordFileUploadUpdateRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordFileUploadUpdateRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.recordFileUploadUpdateRequestWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
         * @summary Perform update operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityBatchUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.updateBatchRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
         * @summary Perform update operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityBatchUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityBatchProcessingApi.updateBatchRequestWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EntityBatchProcessingApi - factory interface
 * @export
 */
export const EntityBatchProcessingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityBatchProcessingApiFp(configuration)
    return {
        /**
         * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.createBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityBatchCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.createBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityBatchCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
         * @summary Get the status of batch request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityBatchResponse> {
            return localVarFp.getStatusOfBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, appId, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
         * @summary Get the status of batch request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityBatchResponse> {
            return localVarFp.getStatusOfBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
         * @summary Get the status of batch file request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfRecordFileUploadRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityBatchResponse> {
            return localVarFp.getStatusOfRecordFileUploadRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, appId, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
         * @summary Get the status of batch file request.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} batchId Unique id of batch request.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusOfRecordFileUploadRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityBatchResponse> {
            return localVarFp.getStatusOfRecordFileUploadRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadCreateRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.recordFileUploadCreateRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
         * @summary Perform create operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadCreateRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.recordFileUploadCreateRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update Entities in batch through CSV file upload.** 
         * @summary Perform update operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadUpdateRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.recordFileUploadUpdateRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update Entities in batch through CSV file upload.** 
         * @summary Perform update operation on Entities via file upload.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordFileUploadUpdateRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.recordFileUploadUpdateRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
         * @summary Perform update operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.updateBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityBatchUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
         * @summary Perform update operation on Entities in batch.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<BatchSuccessResponse> {
            return localVarFp.updateBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityBatchUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityBatchProcessingApi - object-oriented interface
 * @export
 * @class EntityBatchProcessingApi
 * @extends {BaseAPI}
 */
export class EntityBatchProcessingApi extends BaseAPI {
    /**
     * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
     * @summary Perform create operation on Entities in batch.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public createBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).createBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityBatchCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to create Entities in batch via JSON payload for a Entity type specified by EntityTypePluralName.** Category and Subcategory are required if template id is provided 
     * @summary Perform create operation on Entities in batch.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityBatchCreateRequest} entityBatchCreateRequest create batch request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public createBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchCreateRequest: EntityBatchCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).createBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityBatchCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
     * @summary Get the status of batch request.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} batchId Unique id of batch request.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public getStatusOfBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).getStatusOfBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, appId, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
     * @summary Get the status of batch request.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} batchId Unique id of batch request.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public getStatusOfBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).getStatusOfBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get the status of batch request of entity type specified by EntityTypePluralName.** |  Header/Path/Query Parameter   |   Description  |   Type  |  Required   |   |---  |---  |---  |---  |   |  `X-COREOS-REQUEST-ID`(*header*)   |  Unique request ID   |  string   |  Required   |   | `X-COREOS-TID`(*header*) | Tenant ID | string| Required |   | `X-COREOS-AUTH`(*header*) |   Core-os authentication token | string | Optional |   | `X-COREOS-ACCESS`(*header*) | Core-os access token | string | Optional |   | `EntityTypePluralName`<br>(*path*) | Plural name of the entity type. Example: vehicle. | string | Required |   | `batchId`<br>(*query*) | Unique id of batch request | string | Required | 
     * @summary Get the status of batch file request.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} batchId Unique id of batch request.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public getStatusOfRecordFileUploadRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).getStatusOfRecordFileUploadRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, appId, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get the status of batch request of entity type specified by EntityTypePluralName.** 
     * @summary Get the status of batch file request.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} batchId Unique id of batch request.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public getStatusOfRecordFileUploadRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, batchId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).getStatusOfRecordFileUploadRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, batchId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
     * @summary Perform create operation on Entities via file upload.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public recordFileUploadCreateRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).recordFileUploadCreateRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to create Entities in batch through CSV file upload.** Category and Subcategory are required if template id is provided 
     * @summary Perform create operation on Entities via file upload.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public recordFileUploadCreateRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).recordFileUploadCreateRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update Entities in batch through CSV file upload.** 
     * @summary Perform update operation on Entities via file upload.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public recordFileUploadUpdateRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).recordFileUploadUpdateRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update Entities in batch through CSV file upload.** 
     * @summary Perform update operation on Entities via file upload.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityDataFileUpdateRequest} entityDataFileUpdateRequest upload file request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public recordFileUploadUpdateRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityDataFileUpdateRequest: EntityDataFileUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).recordFileUploadUpdateRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityDataFileUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
     * @summary Perform update operation on Entities in batch.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public updateBatchRequest(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).updateBatchRequest(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityBatchUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update Entities core attributes in batch via JSON payload for a entity type specified by EntityTypePluralName.** 
     * @summary Perform update operation on Entities in batch.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityBatchUpdateRequest} entityBatchUpdateRequest update batch request for entity type.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityBatchProcessingApi
     */
    public updateBatchRequestWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityBatchUpdateRequest: EntityBatchUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityBatchProcessingApiFp(this.configuration).updateBatchRequestWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityBatchUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityInstanceApi - axios parameter creator
 * @export
 */
export const EntityInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
         * @summary Create a new Entity
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityWithoutCategory: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityCreateRequestCategory' is not null or undefined
            assertParamExists('addEntityWithoutCategory', 'entityCreateRequestCategory', entityCreateRequestCategory)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityCreateRequestCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
         * @summary Create a new Entity
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityWithoutCategoryWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityCreateRequestCategory' is not null or undefined
            assertParamExists('addEntityWithoutCategoryWithoutAppId', 'entityCreateRequestCategory', entityCreateRequestCategory)
            const localVarPath = `/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityCreateRequestCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get aggregate result for Entity Type** 
         * @summary Aggregate query on the Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {Array<object>} [aggregateQuery] 
         * @param {Query2} [query] Query criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregateOfEntity: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, aggregateQuery?: Array<object>, query?: Query2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getAggregateOfEntity', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getAggregateOfEntity', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getAggregateOfEntity', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getAggregateOfEntity', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getAggregateOfEntity', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/aggregate-query/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aggregateQuery) {
                localVarQueryParameter['aggregateQuery'] = aggregateQuery;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
         * @summary Get list of Entities of a entity type.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithoutCategory: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntitiesWithoutCategory', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntitiesWithoutCategory', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntitiesWithoutCategory', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntitiesWithoutCategory', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEntitiesWithoutCategory', 'appId', appId)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
         * @summary Get list of Entities of a entity type.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithoutCategoryWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntitiesWithoutCategoryWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntitiesWithoutCategoryWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntitiesWithoutCategoryWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntitiesWithoutCategoryWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getEntitiesWithoutCategoryWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
         * @summary Get base & core attribute values of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWithoutCategory: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityWithoutCategory', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityWithoutCategory', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityWithoutCategory', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntityWithoutCategory', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntityWithoutCategory', 'entityId', entityId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEntityWithoutCategory', 'appId', appId)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/{entityId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
         * @summary Get base & core attribute values of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWithoutCategoryWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityWithoutCategoryWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityWithoutCategoryWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityWithoutCategoryWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntityWithoutCategoryWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntityWithoutCategoryWithoutAppId', 'entityId', entityId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getEntityWithoutCategoryWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/{entityTypePluralName}/{entityId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update core attributes of a Entity specified by EntityId.** 
         * @summary Update core attributes of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWithoutCategory: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'entityId', entityId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityUpdateRequest' is not null or undefined
            assertParamExists('updateEntityWithoutCategory', 'entityUpdateRequest', entityUpdateRequest)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/{entityId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update core attributes of a Entity specified by EntityId.** 
         * @summary Update core attributes of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWithoutCategoryWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'entityId', entityId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityUpdateRequest' is not null or undefined
            assertParamExists('updateEntityWithoutCategoryWithoutAppId', 'entityUpdateRequest', entityUpdateRequest)
            const localVarPath = `/{entityTypePluralName}/{entityId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityInstanceApi - functional programming interface
 * @export
 */
export const EntityInstanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityInstanceApiAxiosParamCreator(configuration)
    return {
        /**
         * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
         * @summary Create a new Entity
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityCreateRequestCategory, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.addEntityWithoutCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
         * @summary Create a new Entity
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityCreateRequestCategory, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.addEntityWithoutCategoryWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get aggregate result for Entity Type** 
         * @summary Aggregate query on the Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {Array<object>} [aggregateQuery] 
         * @param {Query2} [query] Query criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregateOfEntity(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, aggregateQuery?: Array<object>, query?: Query2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregateOfEntity(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, aggregateQuery, query, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.getAggregateOfEntity']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
         * @summary Get list of Entities of a entity type.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitiesWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitiesWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.getEntitiesWithoutCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
         * @summary Get list of Entities of a entity type.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitiesWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitiesWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.getEntitiesWithoutCategoryWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
         * @summary Get base & core attribute values of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.getEntityWithoutCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
         * @summary Get base & core attribute values of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.getEntityWithoutCategoryWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update core attributes of a Entity specified by EntityId.** 
         * @summary Update core attributes of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSORIGINTOKEN, entityUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.updateEntityWithoutCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update core attributes of a Entity specified by EntityId.** 
         * @summary Update core attributes of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceApi.updateEntityWithoutCategoryWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EntityInstanceApi - factory interface
 * @export
 */
export const EntityInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityInstanceApiFp(configuration)
    return {
        /**
         * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
         * @summary Create a new Entity
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.addEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityCreateRequestCategory, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
         * @summary Create a new Entity
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.addEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityCreateRequestCategory, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get aggregate result for Entity Type** 
         * @summary Aggregate query on the Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {Array<object>} [aggregateQuery] 
         * @param {Query2} [query] Query criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregateOfEntity(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, aggregateQuery?: Array<object>, query?: Query2, options?: any): AxiosPromise<AggregateResponse> {
            return localVarFp.getAggregateOfEntity(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, aggregateQuery, query, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
         * @summary Get list of Entities of a entity type.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: any): AxiosPromise<EntitiesResponse> {
            return localVarFp.getEntitiesWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
         * @summary Get list of Entities of a entity type.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitiesWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: any): AxiosPromise<EntitiesResponse> {
            return localVarFp.getEntitiesWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
         * @summary Get base & core attribute values of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityResponse> {
            return localVarFp.getEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
         * @summary Get base & core attribute values of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityResponse> {
            return localVarFp.getEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update core attributes of a Entity specified by EntityId.** 
         * @summary Update core attributes of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSORIGINTOKEN, entityUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update core attributes of a Entity specified by EntityId.** 
         * @summary Update core attributes of a Entity.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityInstanceApi - object-oriented interface
 * @export
 * @class EntityInstanceApi
 * @extends {BaseAPI}
 */
export class EntityInstanceApi extends BaseAPI {
    /**
     * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
     * @summary Create a new Entity
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public addEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).addEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityCreateRequestCategory, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for creating a new **Entity** of entity type specified by **entityTypePluralName**. 
     * @summary Create a new Entity
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityCreateRequestCategory} entityCreateRequestCategory Create new Entity
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public addEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityCreateRequestCategory: EntityCreateRequestCategory, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).addEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityCreateRequestCategory, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get aggregate result for Entity Type** 
     * @summary Aggregate query on the Entity Type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {Array<object>} [aggregateQuery] 
     * @param {Query2} [query] Query criteria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public getAggregateOfEntity(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, aggregateQuery?: Array<object>, query?: Query2, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).getAggregateOfEntity(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, aggregateQuery, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
     * @summary Get list of Entities of a entity type.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {number} [limit] Number of items to return.
     * @param {number} [offset] Number of items to skip from start.
     * @param {number} [size] Number of items per page.
     * @param {number} [page] Page number to return(starting from 1).
     * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
     * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
     * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
     * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public getEntitiesWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).getEntitiesWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information of all Entities of entity type specified by EntityTypePluralName, based on the filters specified.** 
     * @summary Get list of Entities of a entity type.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {number} [limit] Number of items to return.
     * @param {number} [offset] Number of items to skip from start.
     * @param {number} [size] Number of items per page.
     * @param {number} [page] Page number to return(starting from 1).
     * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
     * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
     * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
     * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public getEntitiesWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).getEntitiesWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
     * @summary Get base & core attribute values of a Entity.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public getEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).getEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information (base & core attribute values) of a Entity (specified by EntityId) of entity type specified by entityTypePluralName.** 
     * @summary Get base & core attribute values of a Entity.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public getEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).getEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update core attributes of a Entity specified by EntityId.** 
     * @summary Update core attributes of a Entity.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public updateEntityWithoutCategory(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).updateEntityWithoutCategory(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSORIGINTOKEN, entityUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update core attributes of a Entity specified by EntityId.** 
     * @summary Update core attributes of a Entity.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityUpdateRequest} entityUpdateRequest Update Entity
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceApi
     */
    public updateEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityUpdateRequest: EntityUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceApiFp(this.configuration).updateEntityWithoutCategoryWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityInstanceStateApi - axios parameter creator
 * @export
 */
export const EntityInstanceStateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
         * @summary Apply Event to the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCurrentStateOfInstance: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'entityId', entityId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'appId', appId)
            // verify required parameter 'instanceStateUpdateRequest' is not null or undefined
            assertParamExists('changeCurrentStateOfInstance', 'instanceStateUpdateRequest', instanceStateUpdateRequest)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/{entityId}/event`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceStateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
         * @summary Apply Event to the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCurrentStateOfInstanceWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'entityId', entityId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'instanceStateUpdateRequest' is not null or undefined
            assertParamExists('changeCurrentStateOfInstanceWithoutAppId', 'instanceStateUpdateRequest', instanceStateUpdateRequest)
            const localVarPath = `/{entityTypePluralName}/{entityId}/event`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceStateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to get current state of the entity instance 
         * @summary Get current state of the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceState: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getInstanceState', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getInstanceState', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getInstanceState', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getInstanceState', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getInstanceState', 'entityId', entityId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getInstanceState', 'appId', appId)
            const localVarPath = `/apps/{appId}/{entityTypePluralName}/{entityId}/state`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to get current state of the entity instance 
         * @summary Get current state of the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStateWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getInstanceStateWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getInstanceStateWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getInstanceStateWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getInstanceStateWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getInstanceStateWithoutAppId', 'entityId', entityId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getInstanceStateWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/{entityTypePluralName}/{entityId}/state`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityInstanceStateApi - functional programming interface
 * @export
 */
export const EntityInstanceStateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityInstanceStateApiAxiosParamCreator(configuration)
    return {
        /**
         * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
         * @summary Apply Event to the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeCurrentStateOfInstance(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeCurrentStateOfInstance(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, instanceStateUpdateRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceStateApi.changeCurrentStateOfInstance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
         * @summary Apply Event to the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeCurrentStateOfInstanceWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeCurrentStateOfInstanceWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, instanceStateUpdateRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceStateApi.changeCurrentStateOfInstanceWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to get current state of the entity instance 
         * @summary Get current state of the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceState(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceStateGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceState(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceStateApi.getInstanceState']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to get current state of the entity instance 
         * @summary Get current state of the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceStateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceStateGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceStateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityInstanceStateApi.getInstanceStateWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EntityInstanceStateApi - factory interface
 * @export
 */
export const EntityInstanceStateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityInstanceStateApiFp(configuration)
    return {
        /**
         * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
         * @summary Apply Event to the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCurrentStateOfInstance(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.changeCurrentStateOfInstance(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, instanceStateUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
         * @summary Apply Event to the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeCurrentStateOfInstanceWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.changeCurrentStateOfInstanceWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, instanceStateUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * API to get current state of the entity instance 
         * @summary Get current state of the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceState(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<InstanceStateGetResponse> {
            return localVarFp.getInstanceState(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * API to get current state of the entity instance 
         * @summary Get current state of the entity instance
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} entityId Unique id of Entity.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<InstanceStateGetResponse> {
            return localVarFp.getInstanceStateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityInstanceStateApi - object-oriented interface
 * @export
 * @class EntityInstanceStateApi
 * @extends {BaseAPI}
 */
export class EntityInstanceStateApi extends BaseAPI {
    /**
     * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
     * @summary Apply Event to the entity instance
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} appId 
     * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceStateApi
     */
    public changeCurrentStateOfInstance(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceStateApiFp(this.configuration).changeCurrentStateOfInstance(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, instanceStateUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API will apply an event to an instance. If the event is transitionable, then the instance will transition to the particular state. Otherwise it will remain in the existing state 
     * @summary Apply Event to the entity instance
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} xCOREOSAPPID 
     * @param {InstanceStateUpdateRequest} instanceStateUpdateRequest Event for instance of an entity type for state transition.
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceStateApi
     */
    public changeCurrentStateOfInstanceWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, instanceStateUpdateRequest: InstanceStateUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceStateApiFp(this.configuration).changeCurrentStateOfInstanceWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, instanceStateUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to get current state of the entity instance 
     * @summary Get current state of the entity instance
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceStateApi
     */
    public getInstanceState(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceStateApiFp(this.configuration).getInstanceState(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, appId, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to get current state of the entity instance 
     * @summary Get current state of the entity instance
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} entityId Unique id of Entity.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityInstanceStateApi
     */
    public getInstanceStateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, entityId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityInstanceStateApiFp(this.configuration).getInstanceStateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, entityId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityTypeApi - axios parameter creator
 * @export
 */
export const EntityTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for creating a new **Entity Type** 
         * @summary Create a new entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityType: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('addEntityType', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('addEntityType', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('addEntityType', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('addEntityType', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('addEntityType', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityTypeCreateSchema' is not null or undefined
            assertParamExists('addEntityType', 'entityTypeCreateSchema', entityTypeCreateSchema)
            const localVarPath = `/apps/{appId}/entity-type`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityTypeCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for creating a new **Entity Type** 
         * @summary Create a new entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityTypeWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('addEntityTypeWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('addEntityTypeWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('addEntityTypeWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('addEntityTypeWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('addEntityTypeWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityTypeCreateSchema' is not null or undefined
            assertParamExists('addEntityTypeWithoutAppId', 'entityTypeCreateSchema', entityTypeCreateSchema)
            const localVarPath = `/entity-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityTypeCreateSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeByPluralName: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityTypeByPluralName', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityTypeByPluralName', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityTypeByPluralName', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntityTypeByPluralName', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEntityTypeByPluralName', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('getEntityTypeByPluralName', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchByTag !== undefined) {
                localVarQueryParameter['searchByTag'] = searchByTag;
            }

            if (groupByTag !== undefined) {
                localVarQueryParameter['groupByTag'] = groupByTag;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeByPluralNameWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityTypeByPluralNameWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityTypeByPluralNameWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityTypeByPluralNameWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntityTypeByPluralNameWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getEntityTypeByPluralNameWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('getEntityTypeByPluralNameWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            const localVarPath = `/entity-type/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchByTag !== undefined) {
                localVarQueryParameter['searchByTag'] = searchByTag;
            }

            if (groupByTag !== undefined) {
                localVarQueryParameter['groupByTag'] = groupByTag;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all entity types and their basic configuration for a tenant. 
         * @summary Get all entity types and their configurations
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityTypes', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityTypes', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityTypes', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEntityTypes', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('getEntityTypes', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            const localVarPath = `/apps/{appId}/entity-type`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all entity types and their basic configuration for a tenant. 
         * @summary Get all entity types and their configurations
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypesWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityTypesWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityTypesWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityTypesWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getEntityTypesWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('getEntityTypesWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            const localVarPath = `/entity-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityType: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateEntityType', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateEntityType', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateEntityType', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateEntityType', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateEntityType', 'appId', appId)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('updateEntityType', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityTypeUpdateRequest' is not null or undefined
            assertParamExists('updateEntityType', 'entityTypeUpdateRequest', entityTypeUpdateRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityTypeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'xCOREOSORIGINTOKEN' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'xCOREOSORIGINTOKEN', xCOREOSORIGINTOKEN)
            // verify required parameter 'entityTypeUpdateRequest' is not null or undefined
            assertParamExists('updateEntityTypeWithoutAppId', 'entityTypeUpdateRequest', entityTypeUpdateRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSORIGINTOKEN != null) {
                localVarHeaderParameter['X-COREOS-ORIGIN-TOKEN'] = String(xCOREOSORIGINTOKEN);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityTypeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityTypeApi - functional programming interface
 * @export
 */
export const EntityTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * API for creating a new **Entity Type** 
         * @summary Create a new entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityType(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityType(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, xCOREOSORIGINTOKEN, entityTypeCreateSchema, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.addEntityType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API for creating a new **Entity Type** 
         * @summary Create a new entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityTypeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityTypeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityTypeCreateSchema, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.addEntityTypeWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeByPluralName(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeByPluralName(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, searchByTag, groupByTag, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.getEntityTypeByPluralName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeByPluralNameWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeByPluralNameWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, searchByTag, groupByTag, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.getEntityTypeByPluralNameWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get list of all entity types and their basic configuration for a tenant. 
         * @summary Get all entity types and their configurations
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypes(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypes(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.getEntityTypes']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get list of all entity types and their basic configuration for a tenant. 
         * @summary Get all entity types and their configurations
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypesWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypesWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.getEntityTypesWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityType(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityType(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityTypeUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.updateEntityType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityTypeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityTypeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityTypeUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeApi.updateEntityTypeWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EntityTypeApi - factory interface
 * @export
 */
export const EntityTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityTypeApiFp(configuration)
    return {
        /**
         * API for creating a new **Entity Type** 
         * @summary Create a new entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityType(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.addEntityType(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, xCOREOSORIGINTOKEN, entityTypeCreateSchema, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * API for creating a new **Entity Type** 
         * @summary Create a new entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityTypeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.addEntityTypeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityTypeCreateSchema, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeByPluralName(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: any): AxiosPromise<EntityTypeResponse> {
            return localVarFp.getEntityTypeByPluralName(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeByPluralNameWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: any): AxiosPromise<EntityTypeResponse> {
            return localVarFp.getEntityTypeByPluralNameWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all entity types and their basic configuration for a tenant. 
         * @summary Get all entity types and their configurations
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: any): AxiosPromise<EntityTypesResponse> {
            return localVarFp.getEntityTypes(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all entity types and their basic configuration for a tenant. 
         * @summary Get all entity types and their configurations
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {number} [size] Number of items per page.
         * @param {number} [page] Page number to return(starting from 1).
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypesWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: any): AxiosPromise<EntityTypesResponse> {
            return localVarFp.getEntityTypesWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityType(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.updateEntityType(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityTypeUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} xCOREOSORIGINTOKEN core-os origin token
         * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.updateEntityTypeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityTypeUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityTypeApi - object-oriented interface
 * @export
 * @class EntityTypeApi
 * @extends {BaseAPI}
 */
export class EntityTypeApi extends BaseAPI {
    /**
     * API for creating a new **Entity Type** 
     * @summary Create a new entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public addEntityType(xCOREOSREQUESTID?: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).addEntityType(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, xCOREOSORIGINTOKEN, entityTypeCreateSchema, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for creating a new **Entity Type** 
     * @summary Create a new entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityTypeCreateSchema} entityTypeCreateSchema Create new entity type
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public addEntityTypeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeCreateSchema: EntityTypeCreateSchema, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).addEntityTypeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityTypeCreateSchema, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
     * @summary Get configuration of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
     * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypeByPluralName(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypeByPluralName(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get basic configuration of a entity type specified by *EntityTypePluralName*. 
     * @summary Get configuration of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
     * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypeByPluralNameWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypeByPluralNameWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all entity types and their basic configuration for a tenant. 
     * @summary Get all entity types and their configurations
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {number} [limit] Number of items to return.
     * @param {number} [offset] Number of items to skip from start.
     * @param {number} [size] Number of items per page.
     * @param {number} [page] Page number to return(starting from 1).
     * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
     * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
     * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
     * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypes(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypes(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all entity types and their basic configuration for a tenant. 
     * @summary Get all entity types and their configurations
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {number} [limit] Number of items to return.
     * @param {number} [offset] Number of items to skip from start.
     * @param {number} [size] Number of items per page.
     * @param {number} [page] Page number to return(starting from 1).
     * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
     * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
     * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
     * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypesWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, size?: number, page?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypesWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, xCOREOSORIGINTOKEN, xCOREOSUSERINFO, limit, offset, size, page, select, sortKey, query, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
     * @summary Update entity type configuration
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public updateEntityType(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).updateEntityType(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSORIGINTOKEN, entityTypeUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
     * @summary Update entity type configuration
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} xCOREOSORIGINTOKEN core-os origin token
     * @param {EntityTypeUpdateRequest} entityTypeUpdateRequest Update entity type configuration
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public updateEntityTypeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSORIGINTOKEN: string, entityTypeUpdateRequest: EntityTypeUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).updateEntityTypeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSORIGINTOKEN, entityTypeUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityTypeCustomCodeConfigApi - axios parameter creator
 * @export
 */
export const EntityTypeCustomCodeConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * api for registering custom code config
         * @summary register custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityTypeCustomCode: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('createEntityTypeCustomCode', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('createEntityTypeCustomCode', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('createEntityTypeCustomCode', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createEntityTypeCustomCode', 'appId', appId)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('createEntityTypeCustomCode', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'customCodeCreateRequest' is not null or undefined
            assertParamExists('createEntityTypeCustomCode', 'customCodeCreateRequest', customCodeCreateRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/config/handlers`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customCodeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api for registering custom code config
         * @summary register custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityTypeCustomCodeWithooutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('createEntityTypeCustomCodeWithooutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('createEntityTypeCustomCodeWithooutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('createEntityTypeCustomCodeWithooutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('createEntityTypeCustomCodeWithooutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('createEntityTypeCustomCodeWithooutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'customCodeCreateRequest' is not null or undefined
            assertParamExists('createEntityTypeCustomCodeWithooutAppId', 'customCodeCreateRequest', customCodeCreateRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}/config/handlers`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customCodeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api for getting custom code config
         * @summary get custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeCustomCode: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityTypeCustomCode', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityTypeCustomCode', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityTypeCustomCode', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntityTypeCustomCode', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'customCodeId' is not null or undefined
            assertParamExists('getEntityTypeCustomCode', 'customCodeId', customCodeId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEntityTypeCustomCode', 'appId', appId)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/config/handlers/{customCodeId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"customCodeId"}}`, encodeURIComponent(String(customCodeId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api for getting custom code config
         * @summary get custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeCustomCodeWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getEntityTypeCustomCodeWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getEntityTypeCustomCodeWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getEntityTypeCustomCodeWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getEntityTypeCustomCodeWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'customCodeId' is not null or undefined
            assertParamExists('getEntityTypeCustomCodeWithoutAppId', 'customCodeId', customCodeId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getEntityTypeCustomCodeWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/entity-type/{entityTypePluralName}/config/handlers/{customCodeId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"customCodeId"}}`, encodeURIComponent(String(customCodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api for updating custom code config
         * @summary update custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} appId 
         * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeCustomCode: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'customCodeId' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'customCodeId', customCodeId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'appId', appId)
            // verify required parameter 'customCodeUpdateRequest' is not null or undefined
            assertParamExists('updateEntityTypeCustomCode', 'customCodeUpdateRequest', customCodeUpdateRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/config/handlers/{customCodeId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"customCodeId"}}`, encodeURIComponent(String(customCodeId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customCodeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api for updating custom code config
         * @summary update custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeCustomCodeWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'customCodeId' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'customCodeId', customCodeId)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'customCodeUpdateRequest' is not null or undefined
            assertParamExists('updateEntityTypeCustomCodeWithoutAppId', 'customCodeUpdateRequest', customCodeUpdateRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}/config/handlers/{customCodeId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"customCodeId"}}`, encodeURIComponent(String(customCodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customCodeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityTypeCustomCodeConfigApi - functional programming interface
 * @export
 */
export const EntityTypeCustomCodeConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityTypeCustomCodeConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * api for registering custom code config
         * @summary register custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, entityTypePluralName, customCodeCreateRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeCustomCodeConfigApi.createEntityTypeCustomCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * api for registering custom code config
         * @summary register custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityTypeCustomCodeWithooutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityTypeCustomCodeWithooutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, entityTypePluralName, customCodeCreateRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeCustomCodeConfigApi.createEntityTypeCustomCodeWithooutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * api for getting custom code config
         * @summary get custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomCodeConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, appId, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeCustomCodeConfigApi.getEntityTypeCustomCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * api for getting custom code config
         * @summary get custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomCodeConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, xCOREOSAPPID, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeCustomCodeConfigApi.getEntityTypeCustomCodeWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * api for updating custom code config
         * @summary update custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} appId 
         * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, appId, customCodeUpdateRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeCustomCodeConfigApi.updateEntityTypeCustomCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * api for updating custom code config
         * @summary update custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, xCOREOSAPPID, customCodeUpdateRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EntityTypeCustomCodeConfigApi.updateEntityTypeCustomCodeWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EntityTypeCustomCodeConfigApi - factory interface
 * @export
 */
export const EntityTypeCustomCodeConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityTypeCustomCodeConfigApiFp(configuration)
    return {
        /**
         * api for registering custom code config
         * @summary register custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} appId 
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.createEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, entityTypePluralName, customCodeCreateRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * api for registering custom code config
         * @summary register custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} xCOREOSAPPID 
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityTypeCustomCodeWithooutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.createEntityTypeCustomCodeWithooutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, entityTypePluralName, customCodeCreateRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * api for getting custom code config
         * @summary get custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<CustomCodeConfigResponse> {
            return localVarFp.getEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, appId, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * api for getting custom code config
         * @summary get custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<CustomCodeConfigResponse> {
            return localVarFp.getEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * api for updating custom code config
         * @summary update custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} appId 
         * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, appId, customCodeUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * api for updating custom code config
         * @summary update custom code configurations of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} customCodeId Unique id of custom code config for the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, xCOREOSAPPID, customCodeUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityTypeCustomCodeConfigApi - object-oriented interface
 * @export
 * @class EntityTypeCustomCodeConfigApi
 * @extends {BaseAPI}
 */
export class EntityTypeCustomCodeConfigApi extends BaseAPI {
    /**
     * api for registering custom code config
     * @summary register custom code configurations of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} appId 
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeCustomCodeConfigApi
     */
    public createEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, appId: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeCustomCodeConfigApiFp(this.configuration).createEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, appId, entityTypePluralName, customCodeCreateRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api for registering custom code config
     * @summary register custom code configurations of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} xCOREOSAPPID 
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {CustomCodeCreateRequest} customCodeCreateRequest Create new custom code for entityType
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeCustomCodeConfigApi
     */
    public createEntityTypeCustomCodeWithooutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSAPPID: string, entityTypePluralName: string, customCodeCreateRequest: CustomCodeCreateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeCustomCodeConfigApiFp(this.configuration).createEntityTypeCustomCodeWithooutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSAPPID, entityTypePluralName, customCodeCreateRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api for getting custom code config
     * @summary get custom code configurations of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} customCodeId Unique id of custom code config for the entity type.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeCustomCodeConfigApi
     */
    public getEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeCustomCodeConfigApiFp(this.configuration).getEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, appId, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api for getting custom code config
     * @summary get custom code configurations of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} customCodeId Unique id of custom code config for the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeCustomCodeConfigApi
     */
    public getEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeCustomCodeConfigApiFp(this.configuration).getEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api for updating custom code config
     * @summary update custom code configurations of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} customCodeId Unique id of custom code config for the entity type.
     * @param {string} appId 
     * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeCustomCodeConfigApi
     */
    public updateEntityTypeCustomCode(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, appId: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeCustomCodeConfigApiFp(this.configuration).updateEntityTypeCustomCode(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, appId, customCodeUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api for updating custom code config
     * @summary update custom code configurations of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} customCodeId Unique id of custom code config for the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {CustomCodeUpdateRequest} customCodeUpdateRequest Update new custom code for entityType
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeCustomCodeConfigApi
     */
    public updateEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, customCodeId: string, xCOREOSAPPID: string, customCodeUpdateRequest: CustomCodeUpdateRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return EntityTypeCustomCodeConfigApiFp(this.configuration).updateEntityTypeCustomCodeWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, customCodeId, xCOREOSAPPID, customCodeUpdateRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OnboardApi - axios parameter creator
 * @export
 */
export const OnboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Onboard a tenant
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardTenant: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('onboardTenant', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('onboardTenant', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('onboardTenant', 'xCOREOSACCESS', xCOREOSACCESS)
            const localVarPath = `/app/onboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnboardApi - functional programming interface
 * @export
 */
export const OnboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Onboard a tenant
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onboardTenant(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppOnboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.onboardTenant(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnboardApi.onboardTenant']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OnboardApi - factory interface
 * @export
 */
export const OnboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnboardApiFp(configuration)
    return {
        /**
         * 
         * @summary Onboard a tenant
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardTenant(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<AppOnboardResponse> {
            return localVarFp.onboardTenant(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OnboardApi - object-oriented interface
 * @export
 * @class OnboardApi
 * @extends {BaseAPI}
 */
export class OnboardApi extends BaseAPI {
    /**
     * 
     * @summary Onboard a tenant
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardApi
     */
    public onboardTenant(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return OnboardApiFp(this.configuration).onboardTenant(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StateMachineConfigApi - axios parameter creator
 * @export
 */
export const StateMachineConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
         * @summary Register State Machine Config for Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStateMachineConfig: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('createStateMachineConfig', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('createStateMachineConfig', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('createStateMachineConfig', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('createStateMachineConfig', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createStateMachineConfig', 'appId', appId)
            // verify required parameter 'stateMachineRequest' is not null or undefined
            assertParamExists('createStateMachineConfig', 'stateMachineRequest', stateMachineRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/config/state-machine`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stateMachineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
         * @summary Register State Machine Config for Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStateMachineConfigWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('createStateMachineConfigWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('createStateMachineConfigWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('createStateMachineConfigWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('createStateMachineConfigWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('createStateMachineConfigWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'stateMachineRequest' is not null or undefined
            assertParamExists('createStateMachineConfigWithoutAppId', 'stateMachineRequest', stateMachineRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}/config/state-machine`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stateMachineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateMachineConfig: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getStateMachineConfig', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getStateMachineConfig', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getStateMachineConfig', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getStateMachineConfig', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getStateMachineConfig', 'appId', appId)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/config/state-machine`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateMachineConfigWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getStateMachineConfigWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getStateMachineConfigWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getStateMachineConfigWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getStateMachineConfigWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getStateMachineConfigWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            const localVarPath = `/entity-type/{entityTypePluralName}/config/state-machine`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStateMachineConfig: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateStateMachineConfig', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateStateMachineConfig', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateStateMachineConfig', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateStateMachineConfig', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateStateMachineConfig', 'appId', appId)
            // verify required parameter 'stateMachineRequest' is not null or undefined
            assertParamExists('updateStateMachineConfig', 'stateMachineRequest', stateMachineRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/config/state-machine`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stateMachineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStateMachineConfigWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateStateMachineConfigWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateStateMachineConfigWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateStateMachineConfigWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateStateMachineConfigWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('updateStateMachineConfigWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'stateMachineRequest' is not null or undefined
            assertParamExists('updateStateMachineConfigWithoutAppId', 'stateMachineRequest', stateMachineRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}/config/state-machine`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stateMachineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StateMachineConfigApi - functional programming interface
 * @export
 */
export const StateMachineConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StateMachineConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
         * @summary Register State Machine Config for Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, stateMachineRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StateMachineConfigApi.createStateMachineConfig']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
         * @summary Register State Machine Config for Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, stateMachineRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StateMachineConfigApi.createStateMachineConfigWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StateMachineConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StateMachineConfigApi.getStateMachineConfig']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StateMachineConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StateMachineConfigApi.getStateMachineConfigWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, stateMachineRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StateMachineConfigApi.updateStateMachineConfig']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, stateMachineRequest, xCOREOSUSERINFO, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StateMachineConfigApi.updateStateMachineConfigWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StateMachineConfigApi - factory interface
 * @export
 */
export const StateMachineConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StateMachineConfigApiFp(configuration)
    return {
        /**
         * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
         * @summary Register State Machine Config for Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.createStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
         * @summary Register State Machine Config for Entity Type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.createStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<StateMachineConfigResponse> {
            return localVarFp.getStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
         * @summary Get configuration of a entity type
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<StateMachineConfigResponse> {
            return localVarFp.getStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.updateStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
        /**
         * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
         * @summary Update entity type configuration
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: any): AxiosPromise<EntityTypeSuccessResponse> {
            return localVarFp.updateStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StateMachineConfigApi - object-oriented interface
 * @export
 * @class StateMachineConfigApi
 * @extends {BaseAPI}
 */
export class StateMachineConfigApi extends BaseAPI {
    /**
     * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
     * @summary Register State Machine Config for Entity Type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StateMachineConfigApi
     */
    public createStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return StateMachineConfigApiFp(this.configuration).createStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to create basic configuration of an entity type specified by **EntityTypePluralName**. 
     * @summary Register State Machine Config for Entity Type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StateMachineConfigApi
     */
    public createStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return StateMachineConfigApiFp(this.configuration).createStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
     * @summary Get configuration of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StateMachineConfigApi
     */
    public getStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return StateMachineConfigApiFp(this.configuration).getStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get state machine configuration of a entity type specified by *EntityTypePluralName*. 
     * @summary Get configuration of a entity type
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StateMachineConfigApi
     */
    public getStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return StateMachineConfigApiFp(this.configuration).getStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
     * @summary Update entity type configuration
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StateMachineConfigApi
     */
    public updateStateMachineConfig(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return StateMachineConfigApiFp(this.configuration).updateStateMachineConfig(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API to update the basic configuration of a entity type specified by **EntityTypePluralName**. 
     * @summary Update entity type configuration
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {StateMachineRequest} stateMachineRequest State-machine configuration for the entity type
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StateMachineConfigApi
     */
    public updateStateMachineConfigWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, stateMachineRequest: StateMachineRequest, xCOREOSUSERINFO?: string, options?: RawAxiosRequestConfig) {
        return StateMachineConfigApiFp(this.configuration).updateStateMachineConfigWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, stateMachineRequest, xCOREOSUSERINFO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API for creating a new **Template**. 
         * @summary Create a new Template
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {TemplateCreateRequest} templateCreateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('addTemplate', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('addTemplate', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('addTemplate', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('addTemplate', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('addTemplate', 'appId', appId)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('addTemplate', 'categoryName', categoryName)
            // verify required parameter 'templateCreateRequest' is not null or undefined
            assertParamExists('addTemplate', 'templateCreateRequest', templateCreateRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/categories/{categoryName}/templates`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API for creating a new **Template**. 
         * @summary Create a new Template
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {TemplateCreateRequest} templateCreateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplateWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'categoryName', categoryName)
            // verify required parameter 'templateCreateRequest' is not null or undefined
            assertParamExists('addTemplateWithoutAppId', 'templateCreateRequest', templateCreateRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}/categories/{categoryName}/templates`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
         * @summary Get list of Templates of a entity type and category.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getAllTemplates', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getAllTemplates', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getAllTemplates', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getAllTemplates', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getAllTemplates', 'appId', appId)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('getAllTemplates', 'categoryName', categoryName)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/categories/{categoryName}/templates`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
         * @summary Get list of Templates of a entity type and category.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplatesWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getAllTemplatesWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getAllTemplatesWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getAllTemplatesWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getAllTemplatesWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getAllTemplatesWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('getAllTemplatesWithoutAppId', 'categoryName', categoryName)
            const localVarPath = `/entity-type/{entityTypePluralName}/categories/{categoryName}/templates`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (select) {
                localVarQueryParameter['select'] = select;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey;
            }

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information of template with a given template id** 
         * @summary Get a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getTemplate', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getTemplate', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getTemplate', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getTemplate', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getTemplate', 'appId', appId)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('getTemplate', 'categoryName', categoryName)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getTemplate', 'templateId', templateId)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/categories/{categoryName}/templates/{templateId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchByTag !== undefined) {
                localVarQueryParameter['searchByTag'] = searchByTag;
            }

            if (groupByTag !== undefined) {
                localVarQueryParameter['groupByTag'] = groupByTag;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to get information of template with a given template id** 
         * @summary Get a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'categoryName', categoryName)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getTemplateWithoutAppId', 'templateId', templateId)
            const localVarPath = `/entity-type/{entityTypePluralName}/categories/{categoryName}/templates/{templateId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchByTag !== undefined) {
                localVarQueryParameter['searchByTag'] = searchByTag;
            }

            if (groupByTag !== undefined) {
                localVarQueryParameter['groupByTag'] = groupByTag;
            }

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update information of template with a given template id** 
         * @summary Update a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateTemplate', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateTemplate', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateTemplate', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateTemplate', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateTemplate', 'appId', appId)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('updateTemplate', 'categoryName', categoryName)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('updateTemplate', 'templateId', templateId)
            // verify required parameter 'templateUpdateRequest' is not null or undefined
            assertParamExists('updateTemplate', 'templateUpdateRequest', templateUpdateRequest)
            const localVarPath = `/apps/{appId}/entity-type/{entityTypePluralName}/categories/{categoryName}/templates/{templateId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **API to update information of template with a given template id** 
         * @summary Update a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateWithoutAppId: async (xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCOREOSREQUESTID' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'xCOREOSREQUESTID', xCOREOSREQUESTID)
            // verify required parameter 'xCOREOSTID' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'xCOREOSTID', xCOREOSTID)
            // verify required parameter 'xCOREOSACCESS' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'xCOREOSACCESS', xCOREOSACCESS)
            // verify required parameter 'entityTypePluralName' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'entityTypePluralName', entityTypePluralName)
            // verify required parameter 'xCOREOSAPPID' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'xCOREOSAPPID', xCOREOSAPPID)
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'categoryName', categoryName)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'templateId', templateId)
            // verify required parameter 'templateUpdateRequest' is not null or undefined
            assertParamExists('updateTemplateWithoutAppId', 'templateUpdateRequest', templateUpdateRequest)
            const localVarPath = `/entity-type/{entityTypePluralName}/categories/{categoryName}/templates/{templateId}`
                .replace(`{${"entityTypePluralName"}}`, encodeURIComponent(String(entityTypePluralName)))
                .replace(`{${"categoryName"}}`, encodeURIComponent(String(categoryName)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCOREOSREQUESTID != null) {
                localVarHeaderParameter['X-COREOS-REQUEST-ID'] = String(xCOREOSREQUESTID);
            }

            if (xCOREOSTID != null) {
                localVarHeaderParameter['X-COREOS-TID'] = String(xCOREOSTID);
            }

            if (xCOREOSACCESS != null) {
                localVarHeaderParameter['X-COREOS-ACCESS'] = String(xCOREOSACCESS);
            }

            if (xCOREOSUSERINFO != null) {
                localVarHeaderParameter['X-COREOS-USERINFO'] = String(xCOREOSUSERINFO);
            }

            if (xCOREOSAPPID != null) {
                localVarHeaderParameter['X-COREOS-APPID'] = String(xCOREOSAPPID);
            }

            if (xCOREOSCALLBACKSECRET != null) {
                localVarHeaderParameter['X-COREOS-CALLBACK-SECRET'] = String(xCOREOSCALLBACKSECRET);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * API for creating a new **Template**. 
         * @summary Create a new Template
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {TemplateCreateRequest} templateCreateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.addTemplate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * API for creating a new **Template**. 
         * @summary Create a new Template
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {TemplateCreateRequest} templateCreateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.addTemplateWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
         * @summary Get list of Templates of a entity type and category.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTemplates(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTemplates(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, xCOREOSUSERINFO, limit, offset, select, sortKey, query, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.getAllTemplates']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
         * @summary Get list of Templates of a entity type and category.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTemplatesWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTemplatesWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, xCOREOSUSERINFO, limit, offset, select, sortKey, query, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.getAllTemplatesWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information of template with a given template id** 
         * @summary Get a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateId, xCOREOSUSERINFO, searchByTag, groupByTag, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.getTemplate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to get information of template with a given template id** 
         * @summary Get a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateId, xCOREOSUSERINFO, searchByTag, groupByTag, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.getTemplateWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update information of template with a given template id** 
         * @summary Update a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateId, templateUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.updateTemplate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **API to update information of template with a given template id** 
         * @summary Update a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateId, templateUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TemplatesApi.updateTemplateWithoutAppId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * API for creating a new **Template**. 
         * @summary Create a new Template
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {TemplateCreateRequest} templateCreateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.addTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * API for creating a new **Template**. 
         * @summary Create a new Template
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {TemplateCreateRequest} templateCreateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.addTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
         * @summary Get list of Templates of a entity type and category.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: any): AxiosPromise<TemplatesResponse> {
            return localVarFp.getAllTemplates(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, xCOREOSUSERINFO, limit, offset, select, sortKey, query, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
         * @summary Get list of Templates of a entity type and category.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {number} [limit] Number of items to return.
         * @param {number} [offset] Number of items to skip from start.
         * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
         * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
         * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
         * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplatesWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: any): AxiosPromise<TemplatesResponse> {
            return localVarFp.getAllTemplatesWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, xCOREOSUSERINFO, limit, offset, select, sortKey, query, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information of template with a given template id** 
         * @summary Get a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: any): AxiosPromise<TemplateResponse> {
            return localVarFp.getTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateId, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to get information of template with a given template id** 
         * @summary Get a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
         * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: any): AxiosPromise<TemplateResponse> {
            return localVarFp.getTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateId, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update information of template with a given template id** 
         * @summary Update a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} appId 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateId, templateUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
        /**
         * **API to update information of template with a given template id** 
         * @summary Update a template with a given id.
         * @param {string} xCOREOSREQUESTID Unique requestId
         * @param {string} xCOREOSTID Tenant id
         * @param {string} xCOREOSACCESS core-os access token
         * @param {string} entityTypePluralName Plural name of the entity type.
         * @param {string} xCOREOSAPPID 
         * @param {string} categoryName valid category name
         * @param {string} templateId valid template id
         * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
         * @param {string} [xCOREOSUSERINFO] core-os userinfo token
         * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateId, templateUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * API for creating a new **Template**. 
     * @summary Create a new Template
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} categoryName valid category name
     * @param {TemplateCreateRequest} templateCreateRequest Create new template
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public addTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).addTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API for creating a new **Template**. 
     * @summary Create a new Template
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} categoryName valid category name
     * @param {TemplateCreateRequest} templateCreateRequest Create new template
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public addTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateCreateRequest: TemplateCreateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).addTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateCreateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
     * @summary Get list of Templates of a entity type and category.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} categoryName valid category name
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {number} [limit] Number of items to return.
     * @param {number} [offset] Number of items to skip from start.
     * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
     * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
     * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
     * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getAllTemplates(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getAllTemplates(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, xCOREOSUSERINFO, limit, offset, select, sortKey, query, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information of all Templates specified by EntityTypePluralName and category, based on the filters specified.** 
     * @summary Get list of Templates of a entity type and category.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} categoryName valid category name
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {number} [limit] Number of items to return.
     * @param {number} [offset] Number of items to skip from start.
     * @param {Array<string>} [select] Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response. 
     * @param {string} [sortKey] key to be used for sort data, sorting allow only number and string type of values.
     * @param {Query} [query] Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
     * @param {OrderBy} [sortBy] fetching data in ascending(asc) or descending(desc) order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getAllTemplatesWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, xCOREOSUSERINFO?: string, limit?: number, offset?: number, select?: Array<string>, sortKey?: string, query?: Query, sortBy?: OrderBy, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getAllTemplatesWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, xCOREOSUSERINFO, limit, offset, select, sortKey, query, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information of template with a given template id** 
     * @summary Get a template with a given id.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} categoryName valid category name
     * @param {string} templateId valid template id
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
     * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateId, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to get information of template with a given template id** 
     * @summary Get a template with a given id.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} categoryName valid category name
     * @param {string} templateId valid template id
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [searchByTag] Comma separated string containing tag values to filter the attributes.
     * @param {boolean} [groupByTag] Group result on basis of tags. If set to true, then attributes would be returned by grouping the tags associated with the attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, xCOREOSUSERINFO?: string, searchByTag?: string, groupByTag?: boolean, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateId, xCOREOSUSERINFO, searchByTag, groupByTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update information of template with a given template id** 
     * @summary Update a template with a given id.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} appId 
     * @param {string} categoryName valid category name
     * @param {string} templateId valid template id
     * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, appId: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplate(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, appId, categoryName, templateId, templateUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **API to update information of template with a given template id** 
     * @summary Update a template with a given id.
     * @param {string} xCOREOSREQUESTID Unique requestId
     * @param {string} xCOREOSTID Tenant id
     * @param {string} xCOREOSACCESS core-os access token
     * @param {string} entityTypePluralName Plural name of the entity type.
     * @param {string} xCOREOSAPPID 
     * @param {string} categoryName valid category name
     * @param {string} templateId valid template id
     * @param {TemplateUpdateRequest} templateUpdateRequest Create new template
     * @param {string} [xCOREOSUSERINFO] core-os userinfo token
     * @param {string} [xCOREOSCALLBACKSECRET] callback secret (base64 encoded string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplateWithoutAppId(xCOREOSREQUESTID: string, xCOREOSTID: string, xCOREOSACCESS: string, entityTypePluralName: string, xCOREOSAPPID: string, categoryName: string, templateId: string, templateUpdateRequest: TemplateUpdateRequest, xCOREOSUSERINFO?: string, xCOREOSCALLBACKSECRET?: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplateWithoutAppId(xCOREOSREQUESTID, xCOREOSTID, xCOREOSACCESS, entityTypePluralName, xCOREOSAPPID, categoryName, templateId, templateUpdateRequest, xCOREOSUSERINFO, xCOREOSCALLBACKSECRET, options).then((request) => request(this.axios, this.basePath));
    }
}



